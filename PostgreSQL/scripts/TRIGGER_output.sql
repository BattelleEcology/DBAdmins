-- Generated by Ora2Pg, the Oracle database Schema converter, version 20.0
-- Copyright 2000-2019 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=den-certpdr-1.ci.neoninternal.org;sid=C_PDR;port=1521

SET client_encoding TO 'UTF8';

DROP TRIGGER IF EXISTS active_period_before_delete ON active_period CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_active_period_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM ACTIVE_PERIOD_A
   WHERE ACTIVE_PERIOD_ID = OLD.ACTIVE_PERIOD_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM ACTIVE_PERIOD_A
   WHERE ACTIVE_PERIOD_ID = OLD.ACTIVE_PERIOD_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND NAMED_LOCATION_ID = OLD.NAMED_LOCATION_ID AND (START_DATE IS NULL OR START_DATE = OLD.START_DATE) AND (END_DATE IS NULL OR END_DATE = OLD.END_DATE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE ACTIVE_PERIOD_A SET AUDIT_TYPE = 'D'
   WHERE ACTIVE_PERIOD_ID = OLD.ACTIVE_PERIOD_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND NAMED_LOCATION_ID = OLD.NAMED_LOCATION_ID AND (START_DATE = NULL OR START_DATE = OLD.START_DATE) AND (END_DATE = NULL OR END_DATE = OLD.END_DATE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_active_period_before_delete() FROM PUBLIC;

CREATE TRIGGER active_period_before_delete
	BEFORE DELETE ON active_period FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_active_period_before_delete();

DROP TRIGGER IF EXISTS active_period_before_update ON active_period CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_active_period_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO ACTIVE_PERIOD_A(
   ACTIVE_PERIOD_ID,
   NAMED_LOCATION_ID,
   START_DATE,
   END_DATE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ACTIVE_PERIOD_ID,
   OLD.NAMED_LOCATION_ID,
   OLD.START_DATE,
   OLD.END_DATE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_active_period_before_update() FROM PUBLIC;

CREATE TRIGGER active_period_before_update
	BEFORE UPDATE ON active_period FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_active_period_before_update();

DROP TRIGGER IF EXISTS attr_asmt_before_delete ON attr_asmt CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_attr_asmt_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM ATTR_ASMT_A
   WHERE ATTR_ASMT_ID = OLD.ATTR_ASMT_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM ATTR_ASMT_A
   WHERE ATTR_ASMT_ID = OLD.ATTR_ASMT_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (ATTR_ASMT_DESC IS NULL OR ATTR_ASMT_DESC = OLD.ATTR_ASMT_DESC) AND TYPE_ID = OLD.TYPE_ID AND ATTR_ID = OLD.ATTR_ID;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE ATTR_ASMT_A SET AUDIT_TYPE = 'D'
   WHERE ATTR_ASMT_ID = OLD.ATTR_ASMT_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (ATTR_ASMT_DESC = NULL OR ATTR_ASMT_DESC = OLD.ATTR_ASMT_DESC) AND TYPE_ID = OLD.TYPE_ID AND ATTR_ID = OLD.ATTR_ID;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_attr_asmt_before_delete() FROM PUBLIC;

CREATE TRIGGER attr_asmt_before_delete
	BEFORE DELETE ON attr_asmt FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_attr_asmt_before_delete();

DROP TRIGGER IF EXISTS attr_asmt_before_update ON attr_asmt CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_attr_asmt_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO ATTR_ASMT_A(
   ATTR_ASMT_ID,
   ATTR_ASMT_DESC,
   TYPE_ID,
   ATTR_ID,
   TRAN_DATE,
   CHANGE_BY,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ATTR_ASMT_ID,
   OLD.ATTR_ASMT_DESC,
   OLD.TYPE_ID,
   OLD.ATTR_ID,
   OLD.TRAN_DATE,
   OLD.CHANGE_BY,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_attr_asmt_before_update() FROM PUBLIC;

CREATE TRIGGER attr_asmt_before_update
	BEFORE UPDATE ON attr_asmt FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_attr_asmt_before_update();

DROP TRIGGER IF EXISTS attr_before_delete ON attr CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_attr_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM ATTR_A
   WHERE ATTR_ID = OLD.ATTR_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM ATTR_A
   WHERE ATTR_ID = OLD.ATTR_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ATTR_NAME = OLD.ATTR_NAME AND (ATTR_DESC IS NULL OR ATTR_DESC = OLD.ATTR_DESC) AND STRG_TYPE_ID = OLD.STRG_TYPE_ID AND REQD_CHK = OLD.REQD_CHK AND LOV_CHK = OLD.LOV_CHK AND RNGE_CHK = OLD.RNGE_CHK AND (RNGE_MIN_N_VAL IS NULL OR RNGE_MIN_N_VAL = OLD.RNGE_MIN_N_VAL) AND (RNGE_MAX_N_VAL IS NULL OR RNGE_MAX_N_VAL = OLD.RNGE_MAX_N_VAL) AND ATTR_NID = OLD.ATTR_NID AND (RNGE_UNIT_NAME IS NULL OR RNGE_UNIT_NAME = OLD.RNGE_UNIT_NAME) AND (LOV_ID IS NULL OR LOV_ID = OLD.LOV_ID) AND (COLUMN_NAME IS NULL OR COLUMN_NAME = OLD.COLUMN_NAME);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE ATTR_A SET AUDIT_TYPE = 'D'
   WHERE ATTR_ID = OLD.ATTR_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ATTR_NAME = OLD.ATTR_NAME AND (ATTR_DESC = NULL OR ATTR_DESC = OLD.ATTR_DESC) AND STRG_TYPE_ID = OLD.STRG_TYPE_ID AND REQD_CHK = OLD.REQD_CHK AND LOV_CHK = OLD.LOV_CHK AND RNGE_CHK = OLD.RNGE_CHK AND (RNGE_MIN_N_VAL = NULL OR RNGE_MIN_N_VAL = OLD.RNGE_MIN_N_VAL) AND (RNGE_MAX_N_VAL = NULL OR RNGE_MAX_N_VAL = OLD.RNGE_MAX_N_VAL) AND ATTR_NID = OLD.ATTR_NID AND (RNGE_UNIT_NAME = NULL OR RNGE_UNIT_NAME = OLD.RNGE_UNIT_NAME) AND (LOV_ID = NULL OR LOV_ID = OLD.LOV_ID) AND (COLUMN_NAME = NULL OR COLUMN_NAME = OLD.COLUMN_NAME);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_attr_before_delete() FROM PUBLIC;

CREATE TRIGGER attr_before_delete
	BEFORE DELETE ON attr FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_attr_before_delete();

DROP TRIGGER IF EXISTS attr_before_update ON attr CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_attr_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO ATTR_A(
   ATTR_ID,
   ATTR_NAME,
   ATTR_DESC,
   STRG_TYPE_ID,
   REQD_CHK,
   LOV_CHK,
   RNGE_CHK,
   RNGE_MIN_N_VAL,
   RNGE_MAX_N_VAL,
   ATTR_NID,
   RNGE_UNIT_NAME,
   LOV_ID,
   COLUMN_NAME,
   TRAN_DATE,
   CHANGE_BY,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ATTR_ID,
   OLD.ATTR_NAME,
   OLD.ATTR_DESC,
   OLD.STRG_TYPE_ID,
   OLD.REQD_CHK,
   OLD.LOV_CHK,
   OLD.RNGE_CHK,
   OLD.RNGE_MIN_N_VAL,
   OLD.RNGE_MAX_N_VAL,
   OLD.ATTR_NID,
   OLD.RNGE_UNIT_NAME,
   OLD.LOV_ID,
   OLD.COLUMN_NAME,
   OLD.TRAN_DATE,
   OLD.CHANGE_BY,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_attr_before_update() FROM PUBLIC;

CREATE TRIGGER attr_before_update
	BEFORE UPDATE ON attr FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_attr_before_update();

DROP TRIGGER IF EXISTS condition_before_delete ON condition CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_condition_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM CONDITION_A
   WHERE CONDITION_UUID = OLD.CONDITION_UUID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM CONDITION_A
   WHERE CONDITION_UUID = OLD.CONDITION_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND THRESHOLD_UUID = OLD.THRESHOLD_UUID AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND IS_DATE_CONSTRAINED = OLD.IS_DATE_CONSTRAINED AND START_DATE = OLD.START_DATE AND (END_DATE IS NULL OR END_DATE = OLD.END_DATE) AND (START_DAY_OF_YEAR IS NULL OR START_DAY_OF_YEAR = OLD.START_DAY_OF_YEAR) AND (END_DAY_OF_YEAR IS NULL OR END_DAY_OF_YEAR = OLD.END_DAY_OF_YEAR);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE CONDITION_A SET AUDIT_TYPE = 'D'
   WHERE CONDITION_UUID = OLD.CONDITION_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND THRESHOLD_UUID = OLD.THRESHOLD_UUID AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND IS_DATE_CONSTRAINED = OLD.IS_DATE_CONSTRAINED AND START_DATE = OLD.START_DATE AND (END_DATE = NULL OR END_DATE = OLD.END_DATE) AND (START_DAY_OF_YEAR = NULL OR START_DAY_OF_YEAR = OLD.START_DAY_OF_YEAR) AND (END_DAY_OF_YEAR = NULL OR END_DAY_OF_YEAR = OLD.END_DAY_OF_YEAR);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_condition_before_delete() FROM PUBLIC;

CREATE TRIGGER condition_before_delete
	BEFORE DELETE ON condition FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_condition_before_delete();

DROP TRIGGER IF EXISTS condition_before_update ON condition CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_condition_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO CONDITION_A(
   CONDITION_UUID,
   THRESHOLD_UUID,
   NAM_LOCN_ID,
   IS_DATE_CONSTRAINED,
   CHANGE_BY,
   TRAN_DATE,
   START_DATE,
   END_DATE,
   START_DAY_OF_YEAR,
   END_DAY_OF_YEAR,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.CONDITION_UUID,
   OLD.THRESHOLD_UUID,
   OLD.NAM_LOCN_ID,
   OLD.IS_DATE_CONSTRAINED,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.START_DATE,
   OLD.END_DATE,
   OLD.START_DAY_OF_YEAR,
   OLD.END_DAY_OF_YEAR,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_condition_before_update() FROM PUBLIC;

CREATE TRIGGER condition_before_update
	BEFORE UPDATE ON condition FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_condition_before_update();

DROP TRIGGER IF EXISTS constant_before_delete ON constant CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_constant_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM CONSTANT_A
   WHERE CONSTANT_NAME = OLD.CONSTANT_NAME;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM CONSTANT_A
   WHERE CONSTANT_NAME = OLD.CONSTANT_NAME AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND VALUE = OLD.VALUE;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE CONSTANT_A SET AUDIT_TYPE = 'D'
   WHERE CONSTANT_NAME = OLD.CONSTANT_NAME AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND VALUE = OLD.VALUE;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_constant_before_delete() FROM PUBLIC;

CREATE TRIGGER constant_before_delete
	BEFORE DELETE ON constant FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_constant_before_delete();

DROP TRIGGER IF EXISTS constant_before_update ON constant CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_constant_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO CONSTANT_A(
   CONSTANT_NAME,
   VALUE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.CONSTANT_NAME,
   OLD.VALUE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_constant_before_update() FROM PUBLIC;

CREATE TRIGGER constant_before_update
	BEFORE UPDATE ON constant FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_constant_before_update();

DROP TRIGGER IF EXISTS dp_catalog_before_delete ON dp_catalog CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dp_catalog_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM DP_CATALOG_A
   WHERE DP_IDQ = OLD.DP_IDQ;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM DP_CATALOG_A
   WHERE DP_IDQ = OLD.DP_IDQ AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TYPE_ID = OLD.TYPE_ID AND STATUS = OLD.STATUS AND DP_NAME = OLD.DP_NAME AND (DP_DESC IS NULL OR DP_DESC = OLD.DP_DESC) AND (CATEGORY IS NULL OR CATEGORY = OLD.CATEGORY) AND (SUPPLIER IS NULL OR SUPPLIER = OLD.SUPPLIER) AND (DP_SHORTNAME IS NULL OR DP_SHORTNAME = OLD.DP_SHORTNAME) AND (TRANSITION_VERSION IS NULL OR TRANSITION_VERSION = OLD.TRANSITION_VERSION) AND (DP_ABSTRACT IS NULL OR DP_ABSTRACT = OLD.DP_ABSTRACT) AND (DESIGN_DESC IS NULL OR DESIGN_DESC = OLD.DESIGN_DESC) AND (STUDY_DESC IS NULL OR STUDY_DESC = OLD.STUDY_DESC) AND (SENSOR IS NULL OR SENSOR = OLD.SENSOR) AND (CHANGE_LOG IS NULL OR CHANGE_LOG = OLD.CHANGE_LOG) AND (BASIC_DESC IS NULL OR BASIC_DESC = OLD.BASIC_DESC) AND (EXPANDED_DESC IS NULL OR EXPANDED_DESC = OLD.EXPANDED_DESC) AND (REMARKS IS NULL OR REMARKS = OLD.REMARKS) AND (VERSION_NOTES IS NULL OR VERSION_NOTES = OLD.VERSION_NOTES) AND (DATA_SOURCE_TYPE IS NULL OR DATA_SOURCE_TYPE = OLD.DATA_SOURCE_TYPE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE DP_CATALOG_A SET AUDIT_TYPE = 'D'
   WHERE DP_IDQ = OLD.DP_IDQ AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TYPE_ID = OLD.TYPE_ID AND STATUS = OLD.STATUS AND DP_NAME = OLD.DP_NAME AND (DP_DESC = NULL OR DP_DESC = OLD.DP_DESC) AND (CATEGORY = NULL OR CATEGORY = OLD.CATEGORY) AND (SUPPLIER = NULL OR SUPPLIER = OLD.SUPPLIER) AND (DP_SHORTNAME = NULL OR DP_SHORTNAME = OLD.DP_SHORTNAME) AND (TRANSITION_VERSION = NULL OR TRANSITION_VERSION = OLD.TRANSITION_VERSION) AND (DP_ABSTRACT = NULL OR DP_ABSTRACT = OLD.DP_ABSTRACT) AND (DESIGN_DESC = NULL OR DESIGN_DESC = OLD.DESIGN_DESC) AND (STUDY_DESC = NULL OR STUDY_DESC = OLD.STUDY_DESC) AND (SENSOR = NULL OR SENSOR = OLD.SENSOR) AND (CHANGE_LOG = NULL OR CHANGE_LOG = OLD.CHANGE_LOG) AND (BASIC_DESC = NULL OR BASIC_DESC = OLD.BASIC_DESC) AND (EXPANDED_DESC = NULL OR EXPANDED_DESC = OLD.EXPANDED_DESC) AND (REMARKS = NULL OR REMARKS = OLD.REMARKS) AND (VERSION_NOTES = NULL OR VERSION_NOTES = OLD.VERSION_NOTES) AND (DATA_SOURCE_TYPE = NULL OR DATA_SOURCE_TYPE = OLD.DATA_SOURCE_TYPE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_dp_catalog_before_delete() FROM PUBLIC;

CREATE TRIGGER dp_catalog_before_delete
	BEFORE DELETE ON dp_catalog FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_dp_catalog_before_delete();

DROP TRIGGER IF EXISTS dp_catalog_before_update ON dp_catalog CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dp_catalog_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO DP_CATALOG_A(
   DP_IDQ,
   TYPE_ID,
   STATUS,
   DP_NAME,
   DP_DESC,
   CATEGORY,
   SUPPLIER,
   DP_SHORTNAME,
   TRANSITION_VERSION,
   DP_ABSTRACT,
   DESIGN_DESC,
   STUDY_DESC,
   SENSOR,
   CHANGE_LOG,
   BASIC_DESC,
   EXPANDED_DESC,
   REMARKS,
   VERSION_NOTES,
   CHANGE_BY,
   TRAN_DATE,
   DATA_SOURCE_TYPE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.DP_IDQ,
   OLD.TYPE_ID,
   OLD.STATUS,
   OLD.DP_NAME,
   OLD.DP_DESC,
   OLD.CATEGORY,
   OLD.SUPPLIER,
   OLD.DP_SHORTNAME,
   OLD.TRANSITION_VERSION,
   OLD.DP_ABSTRACT,
   OLD.DESIGN_DESC,
   OLD.STUDY_DESC,
   OLD.SENSOR,
   OLD.CHANGE_LOG,
   OLD.BASIC_DESC,
   OLD.EXPANDED_DESC,
   OLD.REMARKS,
   OLD.VERSION_NOTES,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.DATA_SOURCE_TYPE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_dp_catalog_before_update() FROM PUBLIC;

CREATE TRIGGER dp_catalog_before_update
	BEFORE UPDATE ON dp_catalog FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_dp_catalog_before_update();

DROP TRIGGER IF EXISTS dp_site_audit_trigger ON dp_site CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_dp_site_audit_trigger() RETURNS trigger AS $BODY$
DECLARE
   v_username varchar(10);
   v_audit_end_data timestamp;
   v_audit_type char(1);
BEGIN
  BEGIN
   -- Find username of person performing the DELETE on the table
   SELECT user INTO STRICT v_username;
   select CURRENT_TIMESTAMP into STRICT v_audit_end_data;
   case
     when TG_OP = 'UPDATE' then
        v_audit_type := 'U';
     when TG_OP = 'DELETE' then
        v_audit_type := 'D';
   end case;
   insert into dp_site_a(DP_IDQ, SITE, STATUS, AUDIT_END_DATE, AUDIT_END_BY, AUDIT_TYPE)
   values (OLD.DP_IDQ, OLD.SITE,  OLD.STATUS, v_audit_end_data, v_username, v_audit_type);
EXCEPTION
   when others then
   rollback;
  END;
IF TG_OP = 'DELETE' THEN
	RETURN OLD;
ELSE
	RETURN NEW;
END IF;

END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_dp_site_audit_trigger() FROM PUBLIC;

CREATE TRIGGER dp_site_audit_trigger
	BEFORE UPDATE OR DELETE ON dp_site FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_dp_site_audit_trigger();

DROP TRIGGER IF EXISTS is_asset_assignm_before_delete ON is_asset_assignment CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_asset_assignm_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM IS_ASSET_ASSIGNMENT_A
   WHERE ASSET_ASSIGNMENT_ID = OLD.ASSET_ASSIGNMENT_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM IS_ASSET_ASSIGNMENT_A
   WHERE ASSET_ASSIGNMENT_ID = OLD.ASSET_ASSIGNMENT_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ASSET_UID = OLD.ASSET_UID AND ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID AND START_DATE = OLD.START_DATE AND (END_DATE IS NULL OR END_DATE = OLD.END_DATE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE IS_ASSET_ASSIGNMENT_A SET AUDIT_TYPE = 'D'
   WHERE ASSET_ASSIGNMENT_ID = OLD.ASSET_ASSIGNMENT_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ASSET_UID = OLD.ASSET_UID AND ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID AND START_DATE = OLD.START_DATE AND (END_DATE = NULL OR END_DATE = OLD.END_DATE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_asset_assignm_before_delete() FROM PUBLIC;

CREATE TRIGGER is_asset_assignm_before_delete
	BEFORE DELETE ON is_asset_assignment FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_asset_assignm_before_delete();

DROP TRIGGER IF EXISTS is_asset_assignm_before_update ON is_asset_assignment CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_asset_assignm_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO IS_ASSET_ASSIGNMENT_A(
   ASSET_ASSIGNMENT_ID,
   ASSET_UID,
   ASSET_DEFINITION_UUID,
   START_DATE,
   END_DATE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ASSET_ASSIGNMENT_ID,
   OLD.ASSET_UID,
   OLD.ASSET_DEFINITION_UUID,
   OLD.START_DATE,
   OLD.END_DATE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_asset_assignm_before_update() FROM PUBLIC;

CREATE TRIGGER is_asset_assignm_before_update
	BEFORE UPDATE ON is_asset_assignment FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_asset_assignm_before_update();

DROP TRIGGER IF EXISTS is_asset_definit_before_delete ON is_asset_definition CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_asset_definit_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM IS_ASSET_DEFINITION_A
   WHERE ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM IS_ASSET_DEFINITION_A
   WHERE ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ASSET_DEFINITION_NAME = OLD.ASSET_DEFINITION_NAME AND MODEL_NUMBER = OLD.MODEL_NUMBER AND MANUFACTURER_NAME = OLD.MANUFACTURER_NAME AND REVISION_NAME = OLD.REVISION_NAME AND SENSOR_TYPE_NAME = OLD.SENSOR_TYPE_NAME AND ASSET_TYPE_NAME = OLD.ASSET_TYPE_NAME AND (STCDD_NAME IS NULL OR STCDD_NAME = OLD.STCDD_NAME) AND (DESCRIPTION IS NULL OR DESCRIPTION = OLD.DESCRIPTION) AND (SW_VERSION IS NULL OR SW_VERSION = OLD.SW_VERSION) AND (PART_NUMBER IS NULL OR PART_NUMBER = OLD.PART_NUMBER) AND (OBSOLETE_DATE IS NULL OR OBSOLETE_DATE = OLD.OBSOLETE_DATE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE IS_ASSET_DEFINITION_A SET AUDIT_TYPE = 'D'
   WHERE ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ASSET_DEFINITION_NAME = OLD.ASSET_DEFINITION_NAME AND MODEL_NUMBER = OLD.MODEL_NUMBER AND MANUFACTURER_NAME = OLD.MANUFACTURER_NAME AND REVISION_NAME = OLD.REVISION_NAME AND SENSOR_TYPE_NAME = OLD.SENSOR_TYPE_NAME AND ASSET_TYPE_NAME = OLD.ASSET_TYPE_NAME AND (STCDD_NAME = NULL OR STCDD_NAME = OLD.STCDD_NAME) AND (DESCRIPTION = NULL OR DESCRIPTION = OLD.DESCRIPTION) AND (SW_VERSION = NULL OR SW_VERSION = OLD.SW_VERSION) AND (PART_NUMBER = NULL OR PART_NUMBER = OLD.PART_NUMBER) AND (OBSOLETE_DATE = NULL OR OBSOLETE_DATE = OLD.OBSOLETE_DATE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_asset_definit_before_delete() FROM PUBLIC;

CREATE TRIGGER is_asset_definit_before_delete
	BEFORE DELETE ON is_asset_definition FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_asset_definit_before_delete();

DROP TRIGGER IF EXISTS is_asset_definit_before_update ON is_asset_definition CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_asset_definit_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO IS_ASSET_DEFINITION_A(
   ASSET_DEFINITION_UUID,
   ASSET_DEFINITION_NAME,
   MODEL_NUMBER,
   MANUFACTURER_NAME,
   REVISION_NAME,
   SENSOR_TYPE_NAME,
   ASSET_TYPE_NAME,
   STCDD_NAME,
   DESCRIPTION,
   SW_VERSION,
   PART_NUMBER,
   OBSOLETE_DATE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ASSET_DEFINITION_UUID,
   OLD.ASSET_DEFINITION_NAME,
   OLD.MODEL_NUMBER,
   OLD.MANUFACTURER_NAME,
   OLD.REVISION_NAME,
   OLD.SENSOR_TYPE_NAME,
   OLD.ASSET_TYPE_NAME,
   OLD.STCDD_NAME,
   OLD.DESCRIPTION,
   OLD.SW_VERSION,
   OLD.PART_NUMBER,
   OLD.OBSOLETE_DATE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_asset_definit_before_update() FROM PUBLIC;

CREATE TRIGGER is_asset_definit_before_update
	BEFORE UPDATE ON is_asset_definition FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_asset_definit_before_update();

DROP TRIGGER IF EXISTS is_asset_locatio_before_delete ON is_asset_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_asset_locatio_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM IS_ASSET_LOCATION_A
   WHERE ASSET_LOCATION_ID = OLD.ASSET_LOCATION_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM IS_ASSET_LOCATION_A
   WHERE ASSET_LOCATION_ID = OLD.ASSET_LOCATION_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND ASSET_UID = OLD.ASSET_UID AND INSTALL_DATE = OLD.INSTALL_DATE AND (REMOVE_DATE IS NULL OR REMOVE_DATE = OLD.REMOVE_DATE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE IS_ASSET_LOCATION_A SET AUDIT_TYPE = 'D'
   WHERE ASSET_LOCATION_ID = OLD.ASSET_LOCATION_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND ASSET_UID = OLD.ASSET_UID AND INSTALL_DATE = OLD.INSTALL_DATE AND (REMOVE_DATE = NULL OR REMOVE_DATE = OLD.REMOVE_DATE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_asset_locatio_before_delete() FROM PUBLIC;

CREATE TRIGGER is_asset_locatio_before_delete
	BEFORE DELETE ON is_asset_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_asset_locatio_before_delete();

DROP TRIGGER IF EXISTS is_asset_locatio_before_update ON is_asset_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_asset_locatio_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO IS_ASSET_LOCATION_A(
   ASSET_LOCATION_ID,
   NAM_LOCN_ID,
   ASSET_UID,
   INSTALL_DATE,
   REMOVE_DATE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ASSET_LOCATION_ID,
   OLD.NAM_LOCN_ID,
   OLD.ASSET_UID,
   OLD.INSTALL_DATE,
   OLD.REMOVE_DATE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_asset_locatio_before_update() FROM PUBLIC;

CREATE TRIGGER is_asset_locatio_before_update
	BEFORE UPDATE ON is_asset_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_asset_locatio_before_update();

DROP TRIGGER IF EXISTS is_ingest_term_before_delete ON is_ingest_term CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_ingest_term_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM IS_INGEST_TERM_A
   WHERE TERM_NAME = OLD.TERM_NAME AND ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM IS_INGEST_TERM_A
   WHERE TERM_NAME = OLD.TERM_NAME AND ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND STREAM_ID = OLD.STREAM_ID AND CALIBRATION_REQUIRED = OLD.CALIBRATION_REQUIRED AND (SCHEMA_FIELD_NAME IS NULL OR SCHEMA_FIELD_NAME = OLD.SCHEMA_FIELD_NAME);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE IS_INGEST_TERM_A SET AUDIT_TYPE = 'D'
   WHERE TERM_NAME = OLD.TERM_NAME AND ASSET_DEFINITION_UUID = OLD.ASSET_DEFINITION_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND STREAM_ID = OLD.STREAM_ID AND CALIBRATION_REQUIRED = OLD.CALIBRATION_REQUIRED AND (SCHEMA_FIELD_NAME = NULL OR SCHEMA_FIELD_NAME = OLD.SCHEMA_FIELD_NAME);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_ingest_term_before_delete() FROM PUBLIC;

CREATE TRIGGER is_ingest_term_before_delete
	BEFORE DELETE ON is_ingest_term FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_ingest_term_before_delete();

DROP TRIGGER IF EXISTS is_ingest_term_before_update ON is_ingest_term CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_is_ingest_term_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO IS_INGEST_TERM_A(
   TERM_NAME,
   ASSET_DEFINITION_UUID,
   STREAM_ID,
   CALIBRATION_REQUIRED,
   CHANGE_BY,
   TRAN_DATE,
   SCHEMA_FIELD_NAME,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.TERM_NAME,
   OLD.ASSET_DEFINITION_UUID,
   OLD.STREAM_ID,
   OLD.CALIBRATION_REQUIRED,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.SCHEMA_FIELD_NAME,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_is_ingest_term_before_update() FROM PUBLIC;

CREATE TRIGGER is_ingest_term_before_update
	BEFORE UPDATE ON is_ingest_term FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_is_ingest_term_before_update();

DROP TRIGGER IF EXISTS location_metadat_before_delete ON location_metadata CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_location_metadat_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM LOCATION_METADATA_A
   WHERE LOCATION_METADATA_ID = OLD.LOCATION_METADATA_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM LOCATION_METADATA_A
   WHERE LOCATION_METADATA_ID = OLD.LOCATION_METADATA_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND LOCATION_ID = OLD.LOCATION_ID AND NAME = OLD.NAME AND VALUE = OLD.VALUE AND UNITS = OLD.UNITS;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE LOCATION_METADATA_A SET AUDIT_TYPE = 'D'
   WHERE LOCATION_METADATA_ID = OLD.LOCATION_METADATA_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND LOCATION_ID = OLD.LOCATION_ID AND NAME = OLD.NAME AND VALUE = OLD.VALUE AND UNITS = OLD.UNITS;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_location_metadat_before_delete() FROM PUBLIC;

CREATE TRIGGER location_metadat_before_delete
	BEFORE DELETE ON location_metadata FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_location_metadat_before_delete();

DROP TRIGGER IF EXISTS location_metadat_before_update ON location_metadata CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_location_metadat_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO LOCATION_METADATA_A(
   LOCATION_METADATA_ID,
   LOCATION_ID,
   NAME,
   VALUE,
   UNITS,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.LOCATION_METADATA_ID,
   OLD.LOCATION_ID,
   OLD.NAME,
   OLD.VALUE,
   OLD.UNITS,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_location_metadat_before_update() FROM PUBLIC;

CREATE TRIGGER location_metadat_before_update
	BEFORE UPDATE ON location_metadata FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_location_metadat_before_update();

DROP TRIGGER IF EXISTS msg_before_insert ON msg CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_msg_before_insert() RETURNS trigger AS $BODY$
DECLARE
   v_creation_timestamp timestamp(6);
BEGIN
  BEGIN
   select (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') into STRICT v_creation_timestamp;
   NEW.creation_timestamp := v_creation_timestamp;
EXCEPTION
   when others then
   rollback;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_msg_before_insert() FROM PUBLIC;

CREATE TRIGGER msg_before_insert
	BEFORE INSERT ON msg FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_msg_before_insert();

DROP TRIGGER IF EXISTS msg_catalog_before_insert ON msg_catalog CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_msg_catalog_before_insert() RETURNS trigger AS $BODY$
DECLARE
   v_creation_timestamp timestamp(6);
BEGIN
  BEGIN
   select (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') into STRICT v_creation_timestamp;
   NEW.creation_timestamp := v_creation_timestamp;
EXCEPTION
   when others then
   rollback;
  END;
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_msg_catalog_before_insert() FROM PUBLIC;

CREATE TRIGGER msg_catalog_before_insert
	BEFORE INSERT ON msg_catalog FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_msg_catalog_before_insert();

DROP TRIGGER IF EXISTS os_activity_before_delete ON os_activity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_activity_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_ACTIVITY_A
   WHERE ACTIVITY_UUID = OLD.ACTIVITY_UUID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_ACTIVITY_A
   WHERE ACTIVITY_UUID = OLD.ACTIVITY_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND START_DATE = OLD.START_DATE AND END_DATE = OLD.END_DATE AND (MESSAGE_UUID IS NULL OR MESSAGE_UUID = OLD.MESSAGE_UUID);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE OS_ACTIVITY_A SET AUDIT_TYPE = 'D'
   WHERE ACTIVITY_UUID = OLD.ACTIVITY_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND START_DATE = OLD.START_DATE AND END_DATE = OLD.END_DATE AND (MESSAGE_UUID = NULL OR MESSAGE_UUID = OLD.MESSAGE_UUID);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_activity_before_delete() FROM PUBLIC;

CREATE TRIGGER os_activity_before_delete
	BEFORE DELETE ON os_activity FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_activity_before_delete();

DROP TRIGGER IF EXISTS os_activity_before_update ON os_activity CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_activity_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_ACTIVITY_A(
   ACTIVITY_UUID,
   NAM_LOCN_ID,
   INGEST_TABLE_DEF_ID,
   START_DATE,
   END_DATE,
   CHANGE_BY,
   TRAN_DATE,
   MESSAGE_UUID,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ACTIVITY_UUID,
   OLD.NAM_LOCN_ID,
   OLD.INGEST_TABLE_DEF_ID,
   OLD.START_DATE,
   OLD.END_DATE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.MESSAGE_UUID,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_activity_before_update() FROM PUBLIC;

CREATE TRIGGER os_activity_before_update
	BEFORE UPDATE ON os_activity FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_activity_before_update();

DROP TRIGGER IF EXISTS os_activity_x_sa_before_delete ON os_activity_x_sample CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_activity_x_sa_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_ACTIVITY_X_SAMPLE_A
   WHERE ACTIVITY_UUID = OLD.ACTIVITY_UUID AND SAMPLE_UUID = OLD.SAMPLE_UUID;
   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;
   SELECT Count(*) into STRICT row_count
   FROM OS_ACTIVITY_X_SAMPLE_A
   WHERE ACTIVITY_UUID = OLD.ACTIVITY_UUID AND SAMPLE_UUID = OLD.SAMPLE_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (PRIMARY_SAMPLE IS NULL OR PRIMARY_SAMPLE = OLD.PRIMARY_SAMPLE);
   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;
   UPDATE OS_ACTIVITY_X_SAMPLE_A SET AUDIT_TYPE = 'D'
   WHERE ACTIVITY_UUID = OLD.ACTIVITY_UUID AND SAMPLE_UUID = OLD.SAMPLE_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (PRIMARY_SAMPLE = NULL OR PRIMARY_SAMPLE = OLD.PRIMARY_SAMPLE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_activity_x_sa_before_delete() FROM PUBLIC;

CREATE TRIGGER os_activity_x_sa_before_delete
	BEFORE DELETE ON os_activity_x_sample FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_activity_x_sa_before_delete();

DROP TRIGGER IF EXISTS os_activity_x_sa_before_update ON os_activity_x_sample CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_activity_x_sa_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_ACTIVITY_X_SAMPLE_A(
   PRIMARY_SAMPLE,
   CHANGE_BY,
   TRAN_DATE,
   ACTIVITY_UUID,
   SAMPLE_UUID,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.PRIMARY_SAMPLE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.ACTIVITY_UUID,
   OLD.SAMPLE_UUID,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_activity_x_sa_before_update() FROM PUBLIC;

CREATE TRIGGER os_activity_x_sa_before_update
	BEFORE UPDATE ON os_activity_x_sample FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_activity_x_sa_before_update();

DROP TRIGGER IF EXISTS os_field_data_before_delete ON os_field_data CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_field_data_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_FIELD_DATA_A
   WHERE INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID AND ACTIVITY_UUID = OLD.ACTIVITY_UUID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_FIELD_DATA_A
   WHERE INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID AND ACTIVITY_UUID = OLD.ACTIVITY_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (STRING_VALUE IS NULL OR STRING_VALUE = OLD.STRING_VALUE) AND (DATE_VALUE IS NULL OR DATE_VALUE = OLD.DATE_VALUE) AND (NUMBER_VALUE IS NULL OR NUMBER_VALUE = OLD.NUMBER_VALUE) AND (URI_VALUE IS NULL OR URI_VALUE = OLD.URI_VALUE) AND (MIME_TYPE_NAME IS NULL OR MIME_TYPE_NAME = OLD.MIME_TYPE_NAME);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE OS_FIELD_DATA_A SET AUDIT_TYPE = 'D'
   WHERE INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID AND ACTIVITY_UUID = OLD.ACTIVITY_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (STRING_VALUE = NULL OR STRING_VALUE = OLD.STRING_VALUE) AND (DATE_VALUE = NULL OR DATE_VALUE = OLD.DATE_VALUE) AND (NUMBER_VALUE = NULL OR NUMBER_VALUE = OLD.NUMBER_VALUE) AND (URI_VALUE = NULL OR URI_VALUE = OLD.URI_VALUE) AND (MIME_TYPE_NAME = NULL OR MIME_TYPE_NAME = OLD.MIME_TYPE_NAME);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_field_data_before_delete() FROM PUBLIC;

CREATE TRIGGER os_field_data_before_delete
	BEFORE DELETE ON os_field_data FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_field_data_before_delete();

DROP TRIGGER IF EXISTS os_field_data_before_update ON os_field_data CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_field_data_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_FIELD_DATA_A(
   ACTIVITY_UUID,
   INGEST_FIELD_DEF_ID,
   TRAN_DATE,
   CHANGE_BY,
   STRING_VALUE,
   DATE_VALUE,
   NUMBER_VALUE,
   URI_VALUE,
   MIME_TYPE_NAME,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.ACTIVITY_UUID,
   OLD.INGEST_FIELD_DEF_ID,
   OLD.TRAN_DATE,
   OLD.CHANGE_BY,
   OLD.STRING_VALUE,
   OLD.DATE_VALUE,
   OLD.NUMBER_VALUE,
   OLD.URI_VALUE,
   OLD.MIME_TYPE_NAME,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_field_data_before_update() FROM PUBLIC;

CREATE TRIGGER os_field_data_before_update
	BEFORE UPDATE ON os_field_data FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_field_data_before_update();

DROP TRIGGER IF EXISTS os_field_x_sampl_before_delete ON os_field_x_sample_class CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_field_x_sampl_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_FIELD_X_SAMPLE_CLASS_A
   WHERE SAMPLE_CLASS_CODE = OLD.SAMPLE_CLASS_CODE AND INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_FIELD_X_SAMPLE_CLASS_A
   WHERE SAMPLE_CLASS_CODE = OLD.SAMPLE_CLASS_CODE AND INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE OS_FIELD_X_SAMPLE_CLASS_A SET AUDIT_TYPE = 'D'
   WHERE SAMPLE_CLASS_CODE = OLD.SAMPLE_CLASS_CODE AND INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_field_x_sampl_before_delete() FROM PUBLIC;

CREATE TRIGGER os_field_x_sampl_before_delete
	BEFORE DELETE ON os_field_x_sample_class FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_field_x_sampl_before_delete();

DROP TRIGGER IF EXISTS os_field_x_sampl_before_update ON os_field_x_sample_class CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_field_x_sampl_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_FIELD_X_SAMPLE_CLASS_A(
   SAMPLE_CLASS_CODE,
   INGEST_FIELD_DEF_ID,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.SAMPLE_CLASS_CODE,
   OLD.INGEST_FIELD_DEF_ID,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_field_x_sampl_before_update() FROM PUBLIC;

CREATE TRIGGER os_field_x_sampl_before_update
	BEFORE UPDATE ON os_field_x_sample_class FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_field_x_sampl_before_update();

DROP TRIGGER IF EXISTS os_ingest_field_before_delete ON os_ingest_field_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_ingest_field_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_INGEST_FIELD_DEF_A
   WHERE INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_INGEST_FIELD_DEF_A
   WHERE INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND DATA_TYPE_CODE = OLD.DATA_TYPE_CODE AND FIELD_TYPE_CODE = OLD.FIELD_TYPE_CODE AND (UNIT_ID IS NULL OR UNIT_ID = OLD.UNIT_ID) AND (LOV_CODE IS NULL OR LOV_CODE = OLD.LOV_CODE) AND FIELD_NAME = OLD.FIELD_NAME AND (ALT_FIELD_NAME IS NULL OR ALT_FIELD_NAME = OLD.ALT_FIELD_NAME) AND (SMS_FIELD_NAME IS NULL OR SMS_FIELD_NAME = OLD.SMS_FIELD_NAME) AND (DESCRIPTION IS NULL OR DESCRIPTION = OLD.DESCRIPTION) AND (EXAMPLE_ENTRY IS NULL OR EXAMPLE_ENTRY = OLD.EXAMPLE_ENTRY) AND (SAMPLE_INFO IS NULL OR SAMPLE_INFO = OLD.SAMPLE_INFO) AND (SAMPLE_GROUP IS NULL OR SAMPLE_GROUP = OLD.SAMPLE_GROUP) AND (SAMPLE_CLASS IS NULL OR SAMPLE_CLASS = OLD.SAMPLE_CLASS) AND (PARSER_TO_CREATE IS NULL OR PARSER_TO_CREATE = OLD.PARSER_TO_CREATE) AND (PARSER_VALIDATION IS NULL OR PARSER_VALIDATION = OLD.PARSER_VALIDATION) AND (PARSER_PATH IS NULL OR PARSER_PATH = OLD.PARSER_PATH) AND (FORM_VALIDATION IS NULL OR FORM_VALIDATION = OLD.FORM_VALIDATION) AND (RANK IS NULL OR RANK = OLD.RANK);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE OS_INGEST_FIELD_DEF_A SET AUDIT_TYPE = 'D'
   WHERE INGEST_FIELD_DEF_ID = OLD.INGEST_FIELD_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND DATA_TYPE_CODE = OLD.DATA_TYPE_CODE AND FIELD_TYPE_CODE = OLD.FIELD_TYPE_CODE AND (UNIT_ID = NULL OR UNIT_ID = OLD.UNIT_ID) AND (LOV_CODE = NULL OR LOV_CODE = OLD.LOV_CODE) AND FIELD_NAME = OLD.FIELD_NAME AND (ALT_FIELD_NAME = NULL OR ALT_FIELD_NAME = OLD.ALT_FIELD_NAME) AND (SMS_FIELD_NAME = NULL OR SMS_FIELD_NAME = OLD.SMS_FIELD_NAME) AND (DESCRIPTION = NULL OR DESCRIPTION = OLD.DESCRIPTION) AND (EXAMPLE_ENTRY = NULL OR EXAMPLE_ENTRY = OLD.EXAMPLE_ENTRY) AND (SAMPLE_INFO = NULL OR SAMPLE_INFO = OLD.SAMPLE_INFO) AND (SAMPLE_GROUP = NULL OR SAMPLE_GROUP = OLD.SAMPLE_GROUP) AND (SAMPLE_CLASS = NULL OR SAMPLE_CLASS = OLD.SAMPLE_CLASS) AND (PARSER_TO_CREATE = NULL OR PARSER_TO_CREATE = OLD.PARSER_TO_CREATE) AND (PARSER_VALIDATION = NULL OR PARSER_VALIDATION = OLD.PARSER_VALIDATION) AND (PARSER_PATH = NULL OR PARSER_PATH = OLD.PARSER_PATH) AND (FORM_VALIDATION = NULL OR FORM_VALIDATION = OLD.FORM_VALIDATION) AND (RANK = NULL OR RANK = OLD.RANK);
  END;
RETURN OLD;
END;
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_ingest_field_before_delete() FROM PUBLIC;

CREATE TRIGGER os_ingest_field_before_delete
	BEFORE DELETE ON os_ingest_field_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_ingest_field_before_delete();

DROP TRIGGER IF EXISTS os_ingest_field_before_update ON os_ingest_field_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_ingest_field_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_INGEST_FIELD_DEF_A(
   INGEST_FIELD_DEF_ID,
   INGEST_TABLE_DEF_ID,
   DATA_TYPE_CODE,
   FIELD_TYPE_CODE,
   UNIT_ID,
   LOV_CODE,
   FIELD_NAME,
   ALT_FIELD_NAME,
   SMS_FIELD_NAME,
   DESCRIPTION,
   EXAMPLE_ENTRY,
   SAMPLE_INFO,
   SAMPLE_GROUP,
   SAMPLE_CLASS,
   PARSER_TO_CREATE,
   PARSER_VALIDATION,
   PARSER_PATH,
   FORM_VALIDATION,
   CHANGE_BY,
   TRAN_DATE,
   RANK,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.INGEST_FIELD_DEF_ID,
   OLD.INGEST_TABLE_DEF_ID,
   OLD.DATA_TYPE_CODE,
   OLD.FIELD_TYPE_CODE,
   OLD.UNIT_ID,
   OLD.LOV_CODE,
   OLD.FIELD_NAME,
   OLD.ALT_FIELD_NAME,
   OLD.SMS_FIELD_NAME,
   OLD.DESCRIPTION,
   OLD.EXAMPLE_ENTRY,
   OLD.SAMPLE_INFO,
   OLD.SAMPLE_GROUP,
   OLD.SAMPLE_CLASS,
   OLD.PARSER_TO_CREATE,
   OLD.PARSER_VALIDATION,
   OLD.PARSER_PATH,
   OLD.FORM_VALIDATION,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.RANK,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_ingest_field_before_update() FROM PUBLIC;

CREATE TRIGGER os_ingest_field_before_update
	BEFORE UPDATE ON os_ingest_field_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_ingest_field_before_update();

DROP TRIGGER IF EXISTS os_ingest_table__before_delete ON os_ingest_table_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_ingest_table__before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_INGEST_TABLE_DEF_A
   WHERE INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_INGEST_TABLE_DEF_A
   WHERE INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TABLE_NAME = OLD.TABLE_NAME AND DP_IDQ = OLD.DP_IDQ AND ENTRY_METHOD_CODE = OLD.ENTRY_METHOD_CODE AND DESCRIPTION = OLD.DESCRIPTION AND RANK = OLD.RANK AND (FULCRUM_FORM_ID IS NULL OR FULCRUM_FORM_ID = OLD.FULCRUM_FORM_ID) AND (LOAD_DELAY IS NULL OR LOAD_DELAY = OLD.LOAD_DELAY) AND (DELETE_DELAY IS NULL OR DELETE_DELAY = OLD.DELETE_DELAY) AND (REPEATABLE_KEY IS NULL OR REPEATABLE_KEY = OLD.REPEATABLE_KEY) AND (SUPPORT_CONTACTS IS NULL OR SUPPORT_CONTACTS = OLD.SUPPORT_CONTACTS) AND (LOAD_GROUP_CODE IS NULL OR LOAD_GROUP_CODE = OLD.LOAD_GROUP_CODE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE OS_INGEST_TABLE_DEF_A SET AUDIT_TYPE = 'D'
   WHERE INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TABLE_NAME = OLD.TABLE_NAME AND DP_IDQ = OLD.DP_IDQ AND ENTRY_METHOD_CODE = OLD.ENTRY_METHOD_CODE AND DESCRIPTION = OLD.DESCRIPTION AND RANK = OLD.RANK AND (FULCRUM_FORM_ID = NULL OR FULCRUM_FORM_ID = OLD.FULCRUM_FORM_ID) AND (LOAD_DELAY = NULL OR LOAD_DELAY = OLD.LOAD_DELAY) AND (DELETE_DELAY = NULL OR DELETE_DELAY = OLD.DELETE_DELAY) AND (REPEATABLE_KEY = NULL OR REPEATABLE_KEY = OLD.REPEATABLE_KEY) AND (SUPPORT_CONTACTS = NULL OR SUPPORT_CONTACTS = OLD.SUPPORT_CONTACTS) AND (LOAD_GROUP_CODE = NULL OR LOAD_GROUP_CODE = OLD.LOAD_GROUP_CODE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_ingest_table__before_delete() FROM PUBLIC;

CREATE TRIGGER os_ingest_table__before_delete
	BEFORE DELETE ON os_ingest_table_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_ingest_table__before_delete();

DROP TRIGGER IF EXISTS os_ingest_table__before_update ON os_ingest_table_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_ingest_table__before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_INGEST_TABLE_DEF_A(
   INGEST_TABLE_DEF_ID,
   TABLE_NAME,
   DP_IDQ,
   ENTRY_METHOD_CODE,
   DESCRIPTION,
   RANK,
   FULCRUM_FORM_ID,
   LOAD_DELAY,
   DELETE_DELAY,
   REPEATABLE_KEY,
   SUPPORT_CONTACTS,
   CHANGE_BY,
   TRAN_DATE,
   LOAD_GROUP_CODE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.INGEST_TABLE_DEF_ID,
   OLD.TABLE_NAME,
   OLD.DP_IDQ,
   OLD.ENTRY_METHOD_CODE,
   OLD.DESCRIPTION,
   OLD.RANK,
   OLD.FULCRUM_FORM_ID,
   OLD.LOAD_DELAY,
   OLD.DELETE_DELAY,
   OLD.REPEATABLE_KEY,
   OLD.SUPPORT_CONTACTS,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.LOAD_GROUP_CODE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_ingest_table__before_update() FROM PUBLIC;

CREATE TRIGGER os_ingest_table__before_update
	BEFORE UPDATE ON os_ingest_table_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_ingest_table__before_update();

DROP TRIGGER IF EXISTS os_list_of_value_before_delete ON os_list_of_values CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_list_of_value_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_LIST_OF_VALUES_A
   WHERE LOV_CODE = OLD.LOV_CODE;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_LIST_OF_VALUES_A
   WHERE LOV_CODE = OLD.LOV_CODE AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND LIST_TYPE_CODE = OLD.LIST_TYPE_CODE;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE OS_LIST_OF_VALUES_A SET AUDIT_TYPE = 'D'
   WHERE LOV_CODE = OLD.LOV_CODE AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND LIST_TYPE_CODE = OLD.LIST_TYPE_CODE;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_list_of_value_before_delete() FROM PUBLIC;

CREATE TRIGGER os_list_of_value_before_delete
	BEFORE DELETE ON os_list_of_values FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_list_of_value_before_delete();

DROP TRIGGER IF EXISTS os_list_of_value_before_update ON os_list_of_values CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_list_of_value_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_LIST_OF_VALUES_A(
   LOV_CODE,
   LIST_TYPE_CODE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.LOV_CODE,
   OLD.LIST_TYPE_CODE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_list_of_value_before_update() FROM PUBLIC;

CREATE TRIGGER os_list_of_value_before_update
	BEFORE UPDATE ON os_list_of_values FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_list_of_value_before_update();

DROP TRIGGER IF EXISTS os_locn_taxon_before_delete ON os_locn_taxon CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_locn_taxon_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_LOCN_TAXON_A
   WHERE LOCN_TAXON_ID = OLD.LOCN_TAXON_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_LOCN_TAXON_A
   WHERE LOCN_TAXON_ID = OLD.LOCN_TAXON_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TAXON_TYPE_CODE = OLD.TAXON_TYPE_CODE AND TAXON_CODE = OLD.TAXON_CODE AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND NATIVE_STATUS_CODE = OLD.NATIVE_STATUS_CODE AND (NATIVE_STATUS_SRC_REF_ID IS NULL OR NATIVE_STATUS_SRC_REF_ID = OLD.NATIVE_STATUS_SRC_REF_ID) AND (LOCN_STATUS_SRC_REF_ID IS NULL OR LOCN_STATUS_SRC_REF_ID = OLD.LOCN_STATUS_SRC_REF_ID) AND (START_DATE IS NULL OR START_DATE = OLD.START_DATE) AND (END_DATE IS NULL OR END_DATE = OLD.END_DATE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE OS_LOCN_TAXON_A SET AUDIT_TYPE = 'D'
   WHERE LOCN_TAXON_ID = OLD.LOCN_TAXON_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TAXON_TYPE_CODE = OLD.TAXON_TYPE_CODE AND TAXON_CODE = OLD.TAXON_CODE AND NAM_LOCN_ID = OLD.NAM_LOCN_ID AND NATIVE_STATUS_CODE = OLD.NATIVE_STATUS_CODE AND (NATIVE_STATUS_SRC_REF_ID = NULL OR NATIVE_STATUS_SRC_REF_ID = OLD.NATIVE_STATUS_SRC_REF_ID) AND (LOCN_STATUS_SRC_REF_ID = NULL OR LOCN_STATUS_SRC_REF_ID = OLD.LOCN_STATUS_SRC_REF_ID) AND (START_DATE = NULL OR START_DATE = OLD.START_DATE) AND (END_DATE = NULL OR END_DATE = OLD.END_DATE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_locn_taxon_before_delete() FROM PUBLIC;

CREATE TRIGGER os_locn_taxon_before_delete
	BEFORE DELETE ON os_locn_taxon FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_locn_taxon_before_delete();

DROP TRIGGER IF EXISTS os_locn_taxon_before_update ON os_locn_taxon CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_locn_taxon_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_LOCN_TAXON_A(
   TAXON_TYPE_CODE,
   TAXON_CODE,
   NAM_LOCN_ID,
   NATIVE_STATUS_CODE,
   NATIVE_STATUS_SRC_REF_ID,
   LOCN_STATUS_SRC_REF_ID,
   CHANGE_BY,
   TRAN_DATE,
   START_DATE,
   END_DATE,
   LOCN_TAXON_ID,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.TAXON_TYPE_CODE,
   OLD.TAXON_CODE,
   OLD.NAM_LOCN_ID,
   OLD.NATIVE_STATUS_CODE,
   OLD.NATIVE_STATUS_SRC_REF_ID,
   OLD.LOCN_STATUS_SRC_REF_ID,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.START_DATE,
   OLD.END_DATE,
   OLD.LOCN_TAXON_ID,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_locn_taxon_before_update() FROM PUBLIC;

CREATE TRIGGER os_locn_taxon_before_update
	BEFORE UPDATE ON os_locn_taxon FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_locn_taxon_before_update();

DROP TRIGGER IF EXISTS os_lov_item_before_delete ON os_lov_item CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_lov_item_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_LOV_ITEM_A
   WHERE LOV_ITEM_ID = OLD.LOV_ITEM_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_LOV_ITEM_A
   WHERE LOV_ITEM_ID = OLD.LOV_ITEM_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND LOV_CODE = OLD.LOV_CODE AND NAME = OLD.NAME AND RANK = OLD.RANK AND ITEM_CODE = OLD.ITEM_CODE AND EFFECTIVE_DATE = OLD.EFFECTIVE_DATE AND (END_DATE IS NULL OR END_DATE = OLD.END_DATE) AND (PUB_CODE IS NULL OR PUB_CODE = OLD.PUB_CODE) AND (DESCRIPTION IS NULL OR DESCRIPTION = OLD.DESCRIPTION);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE OS_LOV_ITEM_A SET AUDIT_TYPE = 'D'
   WHERE LOV_ITEM_ID = OLD.LOV_ITEM_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND LOV_CODE = OLD.LOV_CODE AND NAME = OLD.NAME AND RANK = OLD.RANK AND ITEM_CODE = OLD.ITEM_CODE AND EFFECTIVE_DATE = OLD.EFFECTIVE_DATE AND (END_DATE = NULL OR END_DATE = OLD.END_DATE) AND (PUB_CODE = NULL OR PUB_CODE = OLD.PUB_CODE) AND (DESCRIPTION = NULL OR DESCRIPTION = OLD.DESCRIPTION);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_lov_item_before_delete() FROM PUBLIC;

CREATE TRIGGER os_lov_item_before_delete
	BEFORE DELETE ON os_lov_item FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_lov_item_before_delete();

DROP TRIGGER IF EXISTS os_lov_item_before_update ON os_lov_item CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_lov_item_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_LOV_ITEM_A(
   LOV_ITEM_ID,
   LOV_CODE,
   NAME,
   RANK,
   ITEM_CODE,
   EFFECTIVE_DATE,
   END_DATE,
   PUB_CODE,
   DESCRIPTION,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.LOV_ITEM_ID,
   OLD.LOV_CODE,
   OLD.NAME,
   OLD.RANK,
   OLD.ITEM_CODE,
   OLD.EFFECTIVE_DATE,
   OLD.END_DATE,
   OLD.PUB_CODE,
   OLD.DESCRIPTION,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_lov_item_before_update() FROM PUBLIC;

CREATE TRIGGER os_lov_item_before_update
	BEFORE UPDATE ON os_lov_item FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_lov_item_before_update();

DROP TRIGGER IF EXISTS os_sample_before_delete ON os_sample CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_sample_before_delete() RETURNS trigger AS $BODY$
DECLARE
	row_count numeric;
	max_tran_date timestamp;
BEGIN
  BEGIN
	SELECT MAX(TRAN_DATE) into STRICT max_tran_date
	FROM OS_SAMPLE_A
	WHERE SAMPLE_UUID = OLD.SAMPLE_UUID;

	IF max_tran_date IS NULL THEN
		RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
	END IF;

	SELECT Count(*) into STRICT row_count
	FROM OS_SAMPLE_A
	WHERE
		SAMPLE_UUID = OLD.SAMPLE_UUID AND
		TRAN_DATE = max_tran_date AND
		AUDIT_END_BY = OLD.CHANGE_BY AND
		SAMPLE_CLASS_CODE = OLD.SAMPLE_CLASS_CODE AND
		SOURCE_TYPE_CODE = OLD.SOURCE_TYPE_CODE AND (SAMPLE_TAG IS NULL OR SAMPLE_TAG = OLD.SAMPLE_TAG) AND (SAMP_BARCODE IS NULL OR SAMP_BARCODE = OLD.SAMP_BARCODE) AND (ARCHIVE_IDENTIFIER IS NULL OR ARCHIVE_IDENTIFIER = OLD.ARCHIVE_IDENTIFIER);

	IF row_count <> 1 THEN
		RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
	END IF;

	UPDATE OS_SAMPLE_A SET AUDIT_TYPE = 'D'
	WHERE
		SAMPLE_UUID = OLD.SAMPLE_UUID AND
		TRAN_DATE = max_tran_date AND
		AUDIT_END_BY = OLD.CHANGE_BY AND
		SAMPLE_CLASS_CODE = OLD.SAMPLE_CLASS_CODE AND
		SOURCE_TYPE_CODE = OLD.SOURCE_TYPE_CODE AND (SAMPLE_TAG = NULL OR SAMPLE_TAG = OLD.SAMPLE_TAG) AND (SAMP_BARCODE = NULL OR SAMP_BARCODE = OLD.SAMP_BARCODE) AND (ARCHIVE_IDENTIFIER = NULL OR ARCHIVE_IDENTIFIER = OLD.ARCHIVE_IDENTIFIER);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_sample_before_delete() FROM PUBLIC;

CREATE TRIGGER os_sample_before_delete
	BEFORE DELETE ON os_sample FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_sample_before_delete();

DROP TRIGGER IF EXISTS os_sample_before_update ON os_sample CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_sample_before_update() RETURNS trigger AS $BODY$
BEGIN
		INSERT INTO OS_SAMPLE_A(
			SAMPLE_UUID,
			SAMPLE_CLASS_CODE,
			SOURCE_TYPE_CODE,
			SAMPLE_TAG,
			SAMP_BARCODE,
			CHANGE_BY,
			TRAN_DATE,
			ARCHIVE_IDENTIFIER,
			AUDIT_END_DATE,
			AUDIT_END_BY,
			AUDIT_TYPE
			)
		VALUES (
			OLD.SAMPLE_UUID,
			OLD.SAMPLE_CLASS_CODE,
			OLD.SOURCE_TYPE_CODE,
			OLD.SAMPLE_TAG,
			OLD.SAMP_BARCODE,
			OLD.CHANGE_BY,
			OLD.TRAN_DATE,
			OLD.ARCHIVE_IDENTIFIER,
			NEW.tran_date,
			NEW.change_by,
			'U'
			);
	RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_sample_before_update() FROM PUBLIC;

CREATE TRIGGER os_sample_before_update
	BEFORE UPDATE ON os_sample FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_sample_before_update();

DROP TRIGGER IF EXISTS os_sample_tree_before_delete ON os_sample_tree CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_sample_tree_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_SAMPLE_TREE_A
   WHERE PARENT_SAMPLE_UUID = OLD.PARENT_SAMPLE_UUID AND CHILD_SAMPLE_UUID = OLD.CHILD_SAMPLE_UUID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_SAMPLE_TREE_A
   WHERE PARENT_SAMPLE_UUID = OLD.PARENT_SAMPLE_UUID AND CHILD_SAMPLE_UUID = OLD.CHILD_SAMPLE_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE OS_SAMPLE_TREE_A SET AUDIT_TYPE = 'D'
   WHERE PARENT_SAMPLE_UUID = OLD.PARENT_SAMPLE_UUID AND CHILD_SAMPLE_UUID = OLD.CHILD_SAMPLE_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_sample_tree_before_delete() FROM PUBLIC;

CREATE TRIGGER os_sample_tree_before_delete
	BEFORE DELETE ON os_sample_tree FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_sample_tree_before_delete();

DROP TRIGGER IF EXISTS os_sample_tree_before_update ON os_sample_tree CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_sample_tree_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_SAMPLE_TREE_A(
   PARENT_SAMPLE_UUID,
   CHILD_SAMPLE_UUID,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.PARENT_SAMPLE_UUID,
   OLD.CHILD_SAMPLE_UUID,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_sample_tree_before_update() FROM PUBLIC;

CREATE TRIGGER os_sample_tree_before_update
	BEFORE UPDATE ON os_sample_tree FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_sample_tree_before_update();

DROP TRIGGER IF EXISTS os_source_refere_before_delete ON os_source_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_source_refere_before_delete() RETURNS trigger AS $BODY$
BEGIN
UPDATE OS_SOURCE_REFERENCE_A SET AUDIT_TYPE = 'D'
WHERE SOURCE_REFERENCE_ID = OLD.SOURCE_REFERENCE_ID AND TRAN_DATE = (
      SELECT MAX(TRAN_DATE) 
      FROM OS_SOURCE_REFERENCE_A
      WHERE SOURCE_REFERENCE_ID = OLD.SOURCE_REFERENCE_ID);
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_source_refere_before_delete() FROM PUBLIC;

CREATE TRIGGER os_source_refere_before_delete
	BEFORE DELETE ON os_source_reference FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_source_refere_before_delete();

DROP TRIGGER IF EXISTS os_source_refere_before_update ON os_source_reference CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_source_refere_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_SOURCE_REFERENCE_A(
   SOURCE_REFERENCE_ID,
   IDENTIFIER,
   TITLE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.SOURCE_REFERENCE_ID,
   OLD.IDENTIFIER,
   OLD.TITLE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_source_refere_before_update() FROM PUBLIC;

CREATE TRIGGER os_source_refere_before_update
	BEFORE UPDATE ON os_source_reference FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_source_refere_before_update();

DROP TRIGGER IF EXISTS os_table_x_nam_l_before_delete ON os_table_x_nam_locn_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_table_x_nam_l_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_TABLE_X_NAM_LOCN_TYPE_A
   WHERE TYPE_ID = OLD.TYPE_ID AND INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_TABLE_X_NAM_LOCN_TYPE_A
   WHERE TYPE_ID = OLD.TYPE_ID AND INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE OS_TABLE_X_NAM_LOCN_TYPE_A SET AUDIT_TYPE = 'D'
   WHERE TYPE_ID = OLD.TYPE_ID AND INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_table_x_nam_l_before_delete() FROM PUBLIC;

CREATE TRIGGER os_table_x_nam_l_before_delete
	BEFORE DELETE ON os_table_x_nam_locn_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_table_x_nam_l_before_delete();

DROP TRIGGER IF EXISTS os_table_x_nam_l_before_update ON os_table_x_nam_locn_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_table_x_nam_l_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_TABLE_X_NAM_LOCN_TYPE_A(
   TYPE_ID,
   INGEST_TABLE_DEF_ID,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.TYPE_ID,
   OLD.INGEST_TABLE_DEF_ID,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_table_x_nam_l_before_update() FROM PUBLIC;

CREATE TRIGGER os_table_x_nam_l_before_update
	BEFORE UPDATE ON os_table_x_nam_locn_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_table_x_nam_l_before_update();

DROP TRIGGER IF EXISTS os_taxon_before_delete ON os_taxon CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_taxon_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM OS_TAXON_A
   WHERE TAXON_CODE = OLD.TAXON_CODE AND TAXON_TYPE_CODE = OLD.TAXON_TYPE_CODE;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM OS_TAXON_A
   WHERE TAXON_CODE = OLD.TAXON_CODE AND TAXON_TYPE_CODE = OLD.TAXON_TYPE_CODE AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ACCEPTED_TAXON_CODE = OLD.ACCEPTED_TAXON_CODE AND SOURCE_REFERENCE_ID = OLD.SOURCE_REFERENCE_ID AND PROTOCOL_CATEGORY_CODE = OLD.PROTOCOL_CATEGORY_CODE AND (TAXON_RANK_CODE IS NULL OR TAXON_RANK_CODE = OLD.TAXON_RANK_CODE) AND (VERNACULAR_NAME IS NULL OR VERNACULAR_NAME = OLD.VERNACULAR_NAME) AND (SCIENTIFIC_NAME IS NULL OR SCIENTIFIC_NAME = OLD.SCIENTIFIC_NAME) AND (SCIENTIFIC_NAME_AUTH IS NULL OR SCIENTIFIC_NAME_AUTH = OLD.SCIENTIFIC_NAME_AUTH) AND (KINGDOM IS NULL OR KINGDOM = OLD.KINGDOM) AND (SUBKINGDOM IS NULL OR SUBKINGDOM = OLD.SUBKINGDOM) AND (INFRAKINGDOM IS NULL OR INFRAKINGDOM = OLD.INFRAKINGDOM) AND (SUPERDIVISION IS NULL OR SUPERDIVISION = OLD.SUPERDIVISION) AND (DIVISION IS NULL OR DIVISION = OLD.DIVISION) AND (SUBDIVISION IS NULL OR SUBDIVISION = OLD.SUBDIVISION) AND (INFRADIVISION IS NULL OR INFRADIVISION =
OLD.INFRADIVISION) AND (PARVDIVISION IS NULL OR PARVDIVISION = OLD.PARVDIVISION) AND (SUPERPHYLUM IS NULL OR SUPERPHYLUM = OLD.SUPERPHYLUM) AND (PHYLUM IS NULL OR PHYLUM = OLD.PHYLUM) AND (SUBPHYLUM IS NULL OR SUBPHYLUM = OLD.SUBPHYLUM) AND (INFRAPHYLUM IS NULL OR INFRAPHYLUM = OLD.INFRAPHYLUM) AND (SUPERCLASS IS NULL OR SUPERCLASS = OLD.SUPERCLASS) AND (TX_CLASS IS NULL OR TX_CLASS = OLD.TX_CLASS) AND (SUBCLASS IS NULL OR SUBCLASS = OLD.SUBCLASS) AND (INFRACLASS IS NULL OR INFRACLASS = OLD.INFRACLASS) AND (SUPERORDER IS NULL OR SUPERORDER = OLD.SUPERORDER) AND (TX_ORDER IS NULL OR TX_ORDER = OLD.TX_ORDER) AND (SUBORDER IS NULL OR SUBORDER = OLD.SUBORDER) AND (INFRAORDER IS NULL OR INFRAORDER = OLD.INFRAORDER) AND (SECTION IS NULL OR SECTION = OLD.SECTION) AND (SUBSECTION IS NULL OR SUBSECTION = OLD.SUBSECTION) AND (SUPERFAMILY IS NULL OR SUPERFAMILY = OLD.SUPERFAMILY) AND (FAMILY IS NULL OR FAMILY = OLD.FAMILY) AND (SUBFAMILY IS NULL OR SUBFAMILY = OLD.SUBFAMILY) AND (TRIBE IS NULL OR TRIBE = OLD.TRIBE) AND (SUBTRIBE IS NULL OR SUBTRIBE = OLD.SUBTRIBE) AND (GENUS IS NULL OR GENUS = OLD.GENUS) AND (SUBGENUS IS NULL OR SUBGENUS = OLD.SUBGENUS) AND (SPECIES IS NULL OR SPECIES = OLD.SPECIES) AND (SUBSPECIES IS NULL OR SUBSPECIES = OLD.SUBSPECIES) AND (VARIETY IS NULL OR VARIETY = OLD.VARIETY) AND (SUBVARIETY IS NULL OR SUBVARIETY = OLD.SUBVARIETY) AND (FORM IS NULL OR FORM = OLD.FORM) AND (SUBFORM IS NULL OR SUBFORM = OLD.SUBFORM) AND (RACE IS NULL OR RACE = OLD.RACE) AND (STIRP IS NULL OR STIRP = OLD.STIRP) AND (MORPH IS NULL OR MORPH = OLD.MORPH) AND (ABBERATION IS NULL OR ABBERATION = OLD.ABBERATION) AND (UNSPECIFIED IS NULL OR UNSPECIFIED = OLD.UNSPECIFIED) AND (SPECIES_GROUP IS NULL OR SPECIES_GROUP = OLD.SPECIES_GROUP) AND (SPEC_EPITHET IS NULL OR SPEC_EPITHET = OLD.SPEC_EPITHET) AND (INFRASPEC_EPITHET IS NULL OR INFRASPEC_EPITHET = OLD.INFRASPEC_EPITHET) AND (START_DATE IS NULL OR START_DATE = OLD.START_DATE) AND (END_DATE IS NULL OR
END_DATE = OLD.END_DATE);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE OS_TAXON_A SET AUDIT_TYPE = 'D'
   WHERE TAXON_CODE = OLD.TAXON_CODE AND TAXON_TYPE_CODE = OLD.TAXON_TYPE_CODE AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND ACCEPTED_TAXON_CODE = OLD.ACCEPTED_TAXON_CODE AND SOURCE_REFERENCE_ID = OLD.SOURCE_REFERENCE_ID AND PROTOCOL_CATEGORY_CODE = OLD.PROTOCOL_CATEGORY_CODE AND (TAXON_RANK_CODE = NULL OR TAXON_RANK_CODE = OLD.TAXON_RANK_CODE) AND (VERNACULAR_NAME = NULL OR VERNACULAR_NAME = OLD.VERNACULAR_NAME) AND (SCIENTIFIC_NAME = NULL OR SCIENTIFIC_NAME = OLD.SCIENTIFIC_NAME) AND (SCIENTIFIC_NAME_AUTH = NULL OR SCIENTIFIC_NAME_AUTH = OLD.SCIENTIFIC_NAME_AUTH) AND (KINGDOM = NULL OR KINGDOM = OLD.KINGDOM) AND (SUBKINGDOM = NULL OR SUBKINGDOM = OLD.SUBKINGDOM) AND (INFRAKINGDOM = NULL OR INFRAKINGDOM = OLD.INFRAKINGDOM) AND (SUPERDIVISION = NULL OR SUPERDIVISION = OLD.SUPERDIVISION) AND (DIVISION = NULL OR DIVISION = OLD.DIVISION) AND (SUBDIVISION = NULL OR SUBDIVISION = OLD.SUBDIVISION) AND (INFRADIVISION = NULL OR INFRADIVISION =
OLD.INFRADIVISION) AND (PARVDIVISION = NULL OR PARVDIVISION = OLD.PARVDIVISION) AND (SUPERPHYLUM = NULL OR SUPERPHYLUM = OLD.SUPERPHYLUM) AND (PHYLUM = NULL OR PHYLUM = OLD.PHYLUM) AND (SUBPHYLUM = NULL OR SUBPHYLUM = OLD.SUBPHYLUM) AND (INFRAPHYLUM = NULL OR INFRAPHYLUM = OLD.INFRAPHYLUM) AND (SUPERCLASS = NULL OR SUPERCLASS = OLD.SUPERCLASS) AND (TX_CLASS = NULL OR TX_CLASS = OLD.TX_CLASS) AND (SUBCLASS = NULL OR SUBCLASS = OLD.SUBCLASS) AND (INFRACLASS = NULL OR INFRACLASS = OLD.INFRACLASS) AND (SUPERORDER = NULL OR SUPERORDER = OLD.SUPERORDER) AND (TX_ORDER = NULL OR TX_ORDER = OLD.TX_ORDER) AND (SUBORDER = NULL OR SUBORDER = OLD.SUBORDER) AND (INFRAORDER = NULL OR INFRAORDER = OLD.INFRAORDER) AND (SECTION = NULL OR SECTION = OLD.SECTION) AND (SUBSECTION = NULL OR SUBSECTION = OLD.SUBSECTION) AND (SUPERFAMILY = NULL OR SUPERFAMILY = OLD.SUPERFAMILY) AND (FAMILY = NULL OR FAMILY = OLD.FAMILY) AND (SUBFAMILY = NULL OR SUBFAMILY = OLD.SUBFAMILY) AND (TRIBE = NULL OR TRIBE = OLD.TRIBE) AND (SUBTRIBE = NULL OR SUBTRIBE = OLD.SUBTRIBE) AND (GENUS = NULL OR GENUS = OLD.GENUS) AND (SUBGENUS = NULL OR SUBGENUS = OLD.SUBGENUS) AND (SPECIES = NULL OR SPECIES = OLD.SPECIES) AND (SUBSPECIES = NULL OR SUBSPECIES = OLD.SUBSPECIES) AND (VARIETY = NULL OR VARIETY = OLD.VARIETY) AND (SUBVARIETY = NULL OR SUBVARIETY = OLD.SUBVARIETY) AND (FORM = NULL OR FORM = OLD.FORM) AND (SUBFORM = NULL OR SUBFORM = OLD.SUBFORM) AND (RACE = NULL OR RACE = OLD.RACE) AND (STIRP = NULL OR STIRP = OLD.STIRP) AND (MORPH = NULL OR MORPH = OLD.MORPH) AND (ABBERATION = NULL OR ABBERATION = OLD.ABBERATION) AND (UNSPECIFIED = NULL OR UNSPECIFIED = OLD.UNSPECIFIED) AND (SPECIES_GROUP = NULL OR SPECIES_GROUP = OLD.SPECIES_GROUP) AND (SPEC_EPITHET = NULL OR SPEC_EPITHET = OLD.SPEC_EPITHET) AND (INFRASPEC_EPITHET = NULL OR INFRASPEC_EPITHET = OLD.INFRASPEC_EPITHET) AND (START_DATE = NULL OR START_DATE = OLD.START_DATE) AND (END_DATE = NULL OR
END_DATE = OLD.END_DATE);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_taxon_before_delete() FROM PUBLIC;

CREATE TRIGGER os_taxon_before_delete
	BEFORE DELETE ON os_taxon FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_taxon_before_delete();

DROP TRIGGER IF EXISTS os_taxon_before_update ON os_taxon CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_os_taxon_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO OS_TAXON_A(
   TAXON_TYPE_CODE,
   TAXON_CODE,
   ACCEPTED_TAXON_CODE,
   SOURCE_REFERENCE_ID,
   PROTOCOL_CATEGORY_CODE,
   TAXON_RANK_CODE,
   CHANGE_BY,
   TRAN_DATE,
   VERNACULAR_NAME,
   SCIENTIFIC_NAME,
   SCIENTIFIC_NAME_AUTH,
   KINGDOM,
   SUBKINGDOM,
   INFRAKINGDOM,
   SUPERDIVISION,
   DIVISION,
   SUBDIVISION,
   INFRADIVISION,
   PARVDIVISION,
   SUPERPHYLUM,
   PHYLUM,
   SUBPHYLUM,
   INFRAPHYLUM,
   SUPERCLASS,
   TX_CLASS,
   SUBCLASS,
   INFRACLASS,
   SUPERORDER,
   TX_ORDER,
   SUBORDER,
   INFRAORDER,
   SECTION,
   SUBSECTION,
   SUPERFAMILY,
   FAMILY,
   SUBFAMILY,
   TRIBE,
   SUBTRIBE,
   GENUS,
   SUBGENUS,
   SPECIES,
   SUBSPECIES,
   VARIETY,
   SUBVARIETY,
   FORM,
   SUBFORM,
   RACE,
   STIRP,
   MORPH,
   ABBERATION,
   UNSPECIFIED,
   SPECIES_GROUP,
   SPEC_EPITHET,
   INFRASPEC_EPITHET,
   START_DATE,
   END_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.TAXON_TYPE_CODE,
   OLD.TAXON_CODE,
   OLD.ACCEPTED_TAXON_CODE,
   OLD.SOURCE_REFERENCE_ID,
   OLD.PROTOCOL_CATEGORY_CODE,
   OLD.TAXON_RANK_CODE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.VERNACULAR_NAME,
   OLD.SCIENTIFIC_NAME,
   OLD.SCIENTIFIC_NAME_AUTH,
   OLD.KINGDOM,
   OLD.SUBKINGDOM,
   OLD.INFRAKINGDOM,
   OLD.SUPERDIVISION,
   OLD.DIVISION,
   OLD.SUBDIVISION,
   OLD.INFRADIVISION,
   OLD.PARVDIVISION,
   OLD.SUPERPHYLUM,
   OLD.PHYLUM,
   OLD.SUBPHYLUM,
   OLD.INFRAPHYLUM,
   OLD.SUPERCLASS,
   OLD.TX_CLASS,
   OLD.SUBCLASS,
   OLD.INFRACLASS,
   OLD.SUPERORDER,
   OLD.TX_ORDER,
   OLD.SUBORDER,
   OLD.INFRAORDER,
   OLD.SECTION,
   OLD.SUBSECTION,
   OLD.SUPERFAMILY,
   OLD.FAMILY,
   OLD.SUBFAMILY,
   OLD.TRIBE,
   OLD.SUBTRIBE,
   OLD.GENUS,
   OLD.SUBGENUS,
   OLD.SPECIES,
   OLD.SUBSPECIES,
   OLD.VARIETY,
   OLD.SUBVARIETY,
   OLD.FORM,
   OLD.SUBFORM,
   OLD.RACE,
   OLD.STIRP,
   OLD.MORPH,
   OLD.ABBERATION,
   OLD.UNSPECIFIED,
   OLD.SPECIES_GROUP,
   OLD.SPEC_EPITHET,
   OLD.INFRASPEC_EPITHET,
   OLD.START_DATE,
   OLD.END_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_os_taxon_before_update() FROM PUBLIC;

CREATE TRIGGER os_taxon_before_update
	BEFORE UPDATE ON os_taxon FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_os_taxon_before_update();

DROP TRIGGER IF EXISTS property_before_delete ON property CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_property_before_delete() RETURNS trigger AS $BODY$
DECLARE
    row_count       numeric;
    max_tran_date   TIMESTAMP;
BEGIN
  BEGIN
    SELECT
        MAX(tran_date)
    INTO STRICT max_tran_date
    FROM
        property_a
    WHERE
        property_id = OLD.property_id;

    IF max_tran_date IS NULL THEN
        RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
    END IF;
    SELECT
        COUNT(*)
    INTO STRICT row_count
    FROM
        property_a
    WHERE
        property_id = OLD.property_id
        AND tran_date = max_tran_date
        AND audit_end_by = OLD.change_by
        AND attr_id = OLD.attr_id
        AND ( nam_locn_id IS NULL
              OR nam_locn_id = OLD.nam_locn_id )
        AND ( condition_uuid IS NULL
              OR condition_uuid = OLD.condition_uuid )
        AND ( locn_id IS NULL
              OR locn_id = OLD.locn_id )
        AND ( string_value IS NULL
              OR string_value = OLD.string_value )
        AND ( date_value IS NULL
              OR date_value = OLD.date_value )
        AND ( number_value IS NULL
              OR number_value = OLD.number_value );

    IF row_count <> 1 THEN
        RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
    END IF;
    UPDATE property_a
    SET
        audit_type = 'D'
    WHERE
        property_id = OLD.property_id
        AND tran_date = max_tran_date
        AND audit_end_by = OLD.change_by
        AND attr_id = OLD.attr_id
        AND ( nam_locn_id = NULL
              OR nam_locn_id = OLD.nam_locn_id )
        AND ( condition_uuid = NULL
              OR condition_uuid = OLD.condition_uuid )
        AND ( locn_id = NULL
              OR locn_id = OLD.locn_id )
        AND ( string_value = NULL
              OR string_value = OLD.string_value )
        AND ( date_value = NULL
              OR date_value = OLD.date_value )
        AND ( number_value = NULL
              OR number_value = OLD.number_value );

  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_property_before_delete() FROM PUBLIC;

CREATE TRIGGER property_before_delete
	BEFORE DELETE ON property FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_property_before_delete();

DROP TRIGGER IF EXISTS property_before_update ON property CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_property_before_update() RETURNS trigger AS $BODY$
BEGIN
    INSERT INTO property_a(
        property_id,
        attr_id,
        nam_locn_id,
        condition_uuid,
        locn_id,
        string_value,
        date_value,
        number_value,
        change_by,
        tran_date,
        audit_end_date,
        audit_end_by,
        audit_type
    ) VALUES (
        OLD.property_id,
        OLD.attr_id,
        OLD.nam_locn_id,
        OLD.condition_uuid,
        OLD.locn_id,
        OLD.string_value,
        OLD.date_value,
        OLD.number_value,
        OLD.change_by,
        OLD.tran_date,
        NEW.tran_date,
        NEW.change_by,
        'U'
    );

RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_property_before_update() FROM PUBLIC;

CREATE TRIGGER property_before_update
	BEFORE UPDATE ON property FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_property_before_update();

DROP TRIGGER IF EXISTS proto_dataset_bd ON proto_dataset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_A(
                    ID,
                    UUID,
                    PROJECT_TITLE,
                    PROJECT_DESCRIPTION,
                    DESIGN_DESCRIPTION,
                    METADATA_DESCRIPTION,
                    STUDY_AREA_DESCRIPTION,
                    ABSTRACT,
                    START_YEAR,
                    END_YEAR,
                    ZIPPED_FILE_SIZE,
                    DATE_UPLOADED,
                    SHAREFILE_PATH,
                    UPLOADER_EMAIL,
                    IS_PUBLISHED,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.UUID,
                    OLD.PROJECT_TITLE,
                    OLD.PROJECT_DESCRIPTION,
                    OLD.DESIGN_DESCRIPTION,
                    OLD.METADATA_DESCRIPTION,
                    OLD.STUDY_AREA_DESCRIPTION,
                    OLD.ABSTRACT,
                    OLD.START_YEAR,
                    OLD.END_YEAR,
                    OLD.ZIPPED_FILE_SIZE,
                    OLD.DATE_UPLOADED,
                    OLD.SHAREFILE_PATH,
                    OLD.UPLOADER_EMAIL,
                    OLD.IS_PUBLISHED,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (UUID IS NULL OR UUID = OLD.UUID)
                    AND (PROJECT_TITLE IS NULL OR PROJECT_TITLE = OLD.PROJECT_TITLE)
                    AND (PROJECT_DESCRIPTION IS NULL OR PROJECT_DESCRIPTION = OLD.PROJECT_DESCRIPTION)
                    AND (DESIGN_DESCRIPTION IS NULL OR DESIGN_DESCRIPTION = OLD.DESIGN_DESCRIPTION)
                    AND (METADATA_DESCRIPTION IS NULL OR METADATA_DESCRIPTION = OLD.METADATA_DESCRIPTION)
                    AND (STUDY_AREA_DESCRIPTION IS NULL OR STUDY_AREA_DESCRIPTION = OLD.STUDY_AREA_DESCRIPTION)
                    AND (ABSTRACT IS NULL OR ABSTRACT = OLD.ABSTRACT)
                    AND (START_YEAR IS NULL OR START_YEAR = OLD.START_YEAR)
                    AND (END_YEAR IS NULL OR END_YEAR = OLD.END_YEAR)
                    AND (ZIPPED_FILE_SIZE IS NULL OR ZIPPED_FILE_SIZE = OLD.ZIPPED_FILE_SIZE)
                    AND DATE_UPLOADED = OLD.DATE_UPLOADED
                    AND (SHAREFILE_PATH IS NULL OR SHAREFILE_PATH = OLD.SHAREFILE_PATH)
                    AND (UPLOADER_EMAIL IS NULL OR UPLOADER_EMAIL = OLD.UPLOADER_EMAIL)
                    AND (IS_PUBLISHED IS NULL OR IS_PUBLISHED = OLD.IS_PUBLISHED);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (UUID = NULL OR UUID = OLD.UUID)
                    AND (PROJECT_TITLE = NULL OR PROJECT_TITLE = OLD.PROJECT_TITLE)
                    AND (PROJECT_DESCRIPTION = NULL OR PROJECT_DESCRIPTION = OLD.PROJECT_DESCRIPTION)
                    AND (DESIGN_DESCRIPTION = NULL OR DESIGN_DESCRIPTION = OLD.DESIGN_DESCRIPTION)
                    AND (METADATA_DESCRIPTION = NULL OR METADATA_DESCRIPTION = OLD.METADATA_DESCRIPTION)
                    AND (STUDY_AREA_DESCRIPTION = NULL OR STUDY_AREA_DESCRIPTION = OLD.STUDY_AREA_DESCRIPTION)
                    AND (ABSTRACT = NULL OR ABSTRACT = OLD.ABSTRACT)
                    AND (START_YEAR = NULL OR START_YEAR = OLD.START_YEAR)
                    AND (END_YEAR = NULL OR END_YEAR = OLD.END_YEAR)
                    AND (ZIPPED_FILE_SIZE = NULL OR ZIPPED_FILE_SIZE = OLD.ZIPPED_FILE_SIZE)
                    AND DATE_UPLOADED = OLD.DATE_UPLOADED
                    AND (SHAREFILE_PATH = NULL OR SHAREFILE_PATH = OLD.SHAREFILE_PATH)
                    AND (UPLOADER_EMAIL = NULL OR UPLOADER_EMAIL = OLD.UPLOADER_EMAIL)
                    AND (IS_PUBLISHED = NULL OR IS_PUBLISHED = OLD.IS_PUBLISHED);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_bd
	BEFORE DELETE ON proto_dataset FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_bd();

DROP TRIGGER IF EXISTS proto_dataset_bu ON proto_dataset CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_A(
                ID,
                UUID,
                PROJECT_TITLE,
                PROJECT_DESCRIPTION,
                DESIGN_DESCRIPTION,
                METADATA_DESCRIPTION,
                STUDY_AREA_DESCRIPTION,
                ABSTRACT,
                START_YEAR,
                END_YEAR,
                ZIPPED_FILE_SIZE,
                DATE_UPLOADED,
                SHAREFILE_PATH,
                UPLOADER_EMAIL,
                IS_PUBLISHED,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.UUID,
                OLD.PROJECT_TITLE,
                OLD.PROJECT_DESCRIPTION,
                OLD.DESIGN_DESCRIPTION,
                OLD.METADATA_DESCRIPTION,
                OLD.STUDY_AREA_DESCRIPTION,
                OLD.ABSTRACT,
                OLD.START_YEAR,
                OLD.END_YEAR,
                OLD.ZIPPED_FILE_SIZE,
                OLD.DATE_UPLOADED,
                OLD.SHAREFILE_PATH,
                OLD.UPLOADER_EMAIL,
                OLD.IS_PUBLISHED,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_bu
	BEFORE UPDATE ON proto_dataset FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_bu();

DROP TRIGGER IF EXISTS proto_dataset_data_object_bd ON proto_dataset_data_object CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_data_object_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_DATA_OBJECT_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (DATASET_UUID = OLD.DATASET_UUID)
                AND (DATA_OBJECT_ID = OLD.DATA_OBJECT_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_DATA_OBJECT_A(
                    DATASET_ID,
                    DATASET_UUID,
                    DATA_OBJECT_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.DATASET_UUID,
                    OLD.DATA_OBJECT_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_DATA_OBJECT_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (DATASET_UUID = OLD.DATASET_UUID)
                    AND (DATA_OBJECT_ID = OLD.DATA_OBJECT_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_DATA_OBJECT_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (DATASET_UUID = OLD.DATASET_UUID)
                    AND (DATA_OBJECT_ID = OLD.DATA_OBJECT_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_data_object_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_data_object_bd
	BEFORE DELETE ON proto_dataset_data_object FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_data_object_bd();

DROP TRIGGER IF EXISTS proto_dataset_data_object_bu ON proto_dataset_data_object CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_data_object_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_DATA_OBJECT_A(
                DATASET_ID,
                DATASET_UUID,
                DATA_OBJECT_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.DATASET_UUID,
                OLD.DATA_OBJECT_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_data_object_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_data_object_bu
	BEFORE UPDATE ON proto_dataset_data_object FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_data_object_bu();

DROP TRIGGER IF EXISTS proto_dataset_data_status_bd ON proto_dataset_data_status CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_data_status_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_DATA_STATUS_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (DATA_STATUS_ID = OLD.DATA_STATUS_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_DATA_STATUS_A(
                    DATASET_ID,
                    DATA_STATUS_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.DATA_STATUS_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_DATA_STATUS_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (DATA_STATUS_ID = OLD.DATA_STATUS_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_DATA_STATUS_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (DATA_STATUS_ID = OLD.DATA_STATUS_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_data_status_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_data_status_bd
	BEFORE DELETE ON proto_dataset_data_status FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_data_status_bd();

DROP TRIGGER IF EXISTS proto_dataset_data_status_bu ON proto_dataset_data_status CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_data_status_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_DATA_STATUS_A(
                DATASET_ID,
                DATA_STATUS_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.DATA_STATUS_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_data_status_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_data_status_bu
	BEFORE UPDATE ON proto_dataset_data_status FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_data_status_bu();

DROP TRIGGER IF EXISTS proto_dataset_data_theme_bd ON proto_dataset_data_theme CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_data_theme_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_DATA_THEME_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (DATA_THEME_ID = OLD.DATA_THEME_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_DATA_THEME_A(
                    DATASET_ID,
                    DATA_THEME_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.DATA_THEME_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_DATA_THEME_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (DATA_THEME_ID = OLD.DATA_THEME_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_DATA_THEME_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (DATA_THEME_ID = OLD.DATA_THEME_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_data_theme_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_data_theme_bd
	BEFORE DELETE ON proto_dataset_data_theme FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_data_theme_bd();

DROP TRIGGER IF EXISTS proto_dataset_data_theme_bu ON proto_dataset_data_theme CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_data_theme_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_DATA_THEME_A(
                DATASET_ID,
                DATA_THEME_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.DATA_THEME_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_data_theme_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_data_theme_bu
	BEFORE UPDATE ON proto_dataset_data_theme FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_data_theme_bu();

DROP TRIGGER IF EXISTS proto_dataset_filetype_bd ON proto_dataset_filetype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_filetype_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_FILETYPE_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (FILETYPE_ID = OLD.FILETYPE_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_FILETYPE_A(
                    DATASET_ID,
                    FILETYPE_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.FILETYPE_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_FILETYPE_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (FILETYPE_ID = OLD.FILETYPE_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_FILETYPE_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (FILETYPE_ID = OLD.FILETYPE_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_filetype_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_filetype_bd
	BEFORE DELETE ON proto_dataset_filetype FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_filetype_bd();

DROP TRIGGER IF EXISTS proto_dataset_filetype_bu ON proto_dataset_filetype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_filetype_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_FILETYPE_A(
                DATASET_ID,
                FILETYPE_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.FILETYPE_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_filetype_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_filetype_bu
	BEFORE UPDATE ON proto_dataset_filetype FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_filetype_bu();

DROP TRIGGER IF EXISTS proto_dataset_keyword_bd ON proto_dataset_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_keyword_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_KEYWORD_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (KEYWORD_ID = OLD.KEYWORD_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_KEYWORD_A(
                    DATASET_ID,
                    KEYWORD_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.KEYWORD_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_KEYWORD_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (KEYWORD_ID = OLD.KEYWORD_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_KEYWORD_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (KEYWORD_ID = OLD.KEYWORD_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_keyword_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_keyword_bd
	BEFORE DELETE ON proto_dataset_keyword FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_keyword_bd();

DROP TRIGGER IF EXISTS proto_dataset_keyword_bu ON proto_dataset_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_keyword_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_KEYWORD_A(
                DATASET_ID,
                KEYWORD_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.KEYWORD_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_keyword_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_keyword_bu
	BEFORE UPDATE ON proto_dataset_keyword FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_keyword_bu();

DROP TRIGGER IF EXISTS proto_dataset_location_bd ON proto_dataset_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_location_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_LOCATION_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (LOCATION_ID = OLD.LOCATION_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_LOCATION_A(
                    DATASET_ID,
                    LOCATION_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.LOCATION_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_LOCATION_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (LOCATION_ID = OLD.LOCATION_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_LOCATION_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (LOCATION_ID = OLD.LOCATION_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_location_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_location_bd
	BEFORE DELETE ON proto_dataset_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_location_bd();

DROP TRIGGER IF EXISTS proto_dataset_location_bu ON proto_dataset_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_location_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_LOCATION_A(
                DATASET_ID,
                LOCATION_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.LOCATION_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_location_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_location_bu
	BEFORE UPDATE ON proto_dataset_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_location_bu();

DROP TRIGGER IF EXISTS proto_dataset_pub_citation_bd ON proto_dataset_pub_citation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_pub_citation_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_PUB_CITATION_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (PUB_CITATION_ID = OLD.PUB_CITATION_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_PUB_CITATION_A(
                    DATASET_ID,
                    PUB_CITATION_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.PUB_CITATION_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_PUB_CITATION_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (PUB_CITATION_ID = OLD.PUB_CITATION_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_PUB_CITATION_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (PUB_CITATION_ID = OLD.PUB_CITATION_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_pub_citation_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_pub_citation_bd
	BEFORE DELETE ON proto_dataset_pub_citation FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_pub_citation_bd();

DROP TRIGGER IF EXISTS proto_dataset_pub_citation_bu ON proto_dataset_pub_citation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_pub_citation_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_PUB_CITATION_A(
                DATASET_ID,
                PUB_CITATION_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.PUB_CITATION_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_pub_citation_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_pub_citation_bu
	BEFORE UPDATE ON proto_dataset_pub_citation FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_pub_citation_bu();

DROP TRIGGER IF EXISTS proto_dataset_related_dp_bd ON proto_dataset_related_dp CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_related_dp_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_RELATED_DP_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (RELATED_DP_ID = OLD.RELATED_DP_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_RELATED_DP_A(
                    DATASET_ID,
                    RELATED_DP_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.RELATED_DP_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_RELATED_DP_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (RELATED_DP_ID = OLD.RELATED_DP_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_RELATED_DP_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (RELATED_DP_ID = OLD.RELATED_DP_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_related_dp_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_related_dp_bd
	BEFORE DELETE ON proto_dataset_related_dp FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_related_dp_bd();

DROP TRIGGER IF EXISTS proto_dataset_related_dp_bu ON proto_dataset_related_dp CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_related_dp_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_RELATED_DP_A(
                DATASET_ID,
                RELATED_DP_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.RELATED_DP_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_related_dp_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_related_dp_bu
	BEFORE UPDATE ON proto_dataset_related_dp FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_related_dp_bu();

DROP TRIGGER IF EXISTS proto_dataset_responsible_bd ON proto_dataset_responsible CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_responsible_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATASET_RESPONSIBLE_A
            WHERE (DATASET_ID = OLD.DATASET_ID)
                AND (RESPONSIBLE_ID = OLD.RESPONSIBLE_ID);

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATASET_RESPONSIBLE_A(
                    DATASET_ID,
                    RESPONSIBLE_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.DATASET_ID,
                    OLD.RESPONSIBLE_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATASET_RESPONSIBLE_A
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (RESPONSIBLE_ID = OLD.RESPONSIBLE_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATASET_RESPONSIBLE_A SET AUDIT_TYPE = 'D'
                WHERE (DATASET_ID = OLD.DATASET_ID)
                    AND (RESPONSIBLE_ID = OLD.RESPONSIBLE_ID)
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY;
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_responsible_bd() FROM PUBLIC;

CREATE TRIGGER proto_dataset_responsible_bd
	BEFORE DELETE ON proto_dataset_responsible FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_responsible_bd();

DROP TRIGGER IF EXISTS proto_dataset_responsible_bu ON proto_dataset_responsible CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_dataset_responsible_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATASET_RESPONSIBLE_A(
                DATASET_ID,
                RESPONSIBLE_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.DATASET_ID,
                OLD.RESPONSIBLE_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_dataset_responsible_bu() FROM PUBLIC;

CREATE TRIGGER proto_dataset_responsible_bu
	BEFORE UPDATE ON proto_dataset_responsible FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_dataset_responsible_bu();

DROP TRIGGER IF EXISTS proto_data_object_bd ON proto_data_object CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_data_object_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATA_OBJECT_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATA_OBJECT_A(
                    ID,
                    NAME,
                    DESCRIPTION,
                    IS_DOWNLOADABLE,
                    OBJECT_ID,
                    OBJECT_TYPE_ID,
                    OBJECT_SIZE,
                    CHECKSUM,
                    S3_VERSION,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.NAME,
                    OLD.DESCRIPTION,
                    OLD.IS_DOWNLOADABLE,
                    OLD.OBJECT_ID,
                    OLD.OBJECT_TYPE_ID,
                    OLD.OBJECT_SIZE,
                    OLD.CHECKSUM,
                    OLD.S3_VERSION,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATA_OBJECT_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME IS NULL OR NAME = OLD.NAME)
                    AND (DESCRIPTION IS NULL OR DESCRIPTION = OLD.DESCRIPTION)
                    AND (IS_DOWNLOADABLE IS NULL OR IS_DOWNLOADABLE = OLD.IS_DOWNLOADABLE)
                    AND (OBJECT_ID = OLD.OBJECT_ID)
                    AND (OBJECT_TYPE_ID = OLD.OBJECT_TYPE_ID)
                    AND (OBJECT_SIZE = OLD.OBJECT_SIZE)
                    AND (CHECKSUM = OLD.CHECKSUM)
                    AND (S3_VERSION = OLD.S3_VERSION);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATA_OBJECT_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME = NULL OR NAME = OLD.NAME)
                    AND (DESCRIPTION = NULL OR DESCRIPTION = OLD.DESCRIPTION)
                    AND (IS_DOWNLOADABLE = NULL OR IS_DOWNLOADABLE = OLD.IS_DOWNLOADABLE)
                    AND (OBJECT_ID = OLD.OBJECT_ID)
                    AND (OBJECT_TYPE_ID = OLD.OBJECT_TYPE_ID)
                    AND (OBJECT_SIZE = OLD.OBJECT_SIZE)
                    AND (CHECKSUM = OLD.CHECKSUM)
                    AND (S3_VERSION = OLD.S3_VERSION);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_data_object_bd() FROM PUBLIC;

CREATE TRIGGER proto_data_object_bd
	BEFORE DELETE ON proto_data_object FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_data_object_bd();

DROP TRIGGER IF EXISTS proto_data_object_bu ON proto_data_object CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_data_object_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATA_OBJECT_A(
                ID,
                NAME,
                DESCRIPTION,
                IS_DOWNLOADABLE,
                OBJECT_ID,
                OBJECT_TYPE_ID,
                OBJECT_SIZE,
                CHECKSUM,
                S3_VERSION,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.NAME,
                OLD.DESCRIPTION,
                OLD.IS_DOWNLOADABLE,
                OLD.OBJECT_ID,
                OLD.OBJECT_TYPE_ID,
                OLD.OBJECT_SIZE,
                OLD.CHECKSUM,
                OLD.S3_VERSION,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_data_object_bu() FROM PUBLIC;

CREATE TRIGGER proto_data_object_bu
	BEFORE UPDATE ON proto_data_object FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_data_object_bu();

DROP TRIGGER IF EXISTS proto_data_status_bd ON proto_data_status CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_data_status_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATA_STATUS_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATA_STATUS_A(
                    ID,
                    NAME,
                    IS_SUBMITTED_STATUS,
                    IS_READY_FOR_PROCESSING_STATUS,
                    IS_IN_PROCESS_STATUS,
                    IS_REVIEW_REQUIRED_STATUS,
                    IS_SEARCHABLE_STATUS,
                    IS_ARCHIVED_STATUS,
                    IS_DELETED_STATUS,
                    IS_IN_ERROR_STATUS,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.NAME,
                    OLD.IS_SUBMITTED_STATUS,
                    OLD.IS_READY_FOR_PROCESSING_STATUS,
                    OLD.IS_IN_PROCESS_STATUS,
                    OLD.IS_REVIEW_REQUIRED_STATUS,
                    OLD.IS_SEARCHABLE_STATUS,
                    OLD.IS_ARCHIVED_STATUS,
                    OLD.IS_DELETED_STATUS,
                    OLD.IS_IN_ERROR_STATUS,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATA_STATUS_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME IS NULL OR NAME = OLD.NAME)
                    AND (IS_SUBMITTED_STATUS IS NULL OR IS_SUBMITTED_STATUS = OLD.IS_SUBMITTED_STATUS)
                    AND (IS_READY_FOR_PROCESSING_STATUS IS NULL OR IS_READY_FOR_PROCESSING_STATUS = OLD.IS_READY_FOR_PROCESSING_STATUS)
                    AND (IS_IN_PROCESS_STATUS IS NULL OR IS_IN_PROCESS_STATUS = OLD.IS_IN_PROCESS_STATUS)
                    AND (IS_REVIEW_REQUIRED_STATUS IS NULL OR IS_REVIEW_REQUIRED_STATUS = OLD.IS_REVIEW_REQUIRED_STATUS)
                    AND (IS_SEARCHABLE_STATUS IS NULL OR IS_SEARCHABLE_STATUS = OLD.IS_SEARCHABLE_STATUS)
                    AND (IS_ARCHIVED_STATUS IS NULL OR IS_ARCHIVED_STATUS = OLD.IS_ARCHIVED_STATUS)
                    AND (IS_DELETED_STATUS IS NULL OR IS_DELETED_STATUS = OLD.IS_DELETED_STATUS)
                    AND (IS_IN_ERROR_STATUS IS NULL OR IS_IN_ERROR_STATUS = OLD.IS_IN_ERROR_STATUS);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATA_STATUS_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME = NULL OR NAME = OLD.NAME)
                    AND (IS_SUBMITTED_STATUS = NULL OR IS_SUBMITTED_STATUS = OLD.IS_SUBMITTED_STATUS)
                    AND (IS_READY_FOR_PROCESSING_STATUS = NULL OR IS_READY_FOR_PROCESSING_STATUS = OLD.IS_READY_FOR_PROCESSING_STATUS)
                    AND (IS_IN_PROCESS_STATUS = NULL OR IS_IN_PROCESS_STATUS = OLD.IS_IN_PROCESS_STATUS)
                    AND (IS_REVIEW_REQUIRED_STATUS = NULL OR IS_REVIEW_REQUIRED_STATUS = OLD.IS_REVIEW_REQUIRED_STATUS)
                    AND (IS_SEARCHABLE_STATUS = NULL OR IS_SEARCHABLE_STATUS = OLD.IS_SEARCHABLE_STATUS)
                    AND (IS_ARCHIVED_STATUS = NULL OR IS_ARCHIVED_STATUS = OLD.IS_ARCHIVED_STATUS)
                    AND (IS_DELETED_STATUS = NULL OR IS_DELETED_STATUS = OLD.IS_DELETED_STATUS)
                    AND (IS_IN_ERROR_STATUS = NULL OR IS_IN_ERROR_STATUS = OLD.IS_IN_ERROR_STATUS);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_data_status_bd() FROM PUBLIC;

CREATE TRIGGER proto_data_status_bd
	BEFORE DELETE ON proto_data_status FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_data_status_bd();

DROP TRIGGER IF EXISTS proto_data_status_bu ON proto_data_status CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_data_status_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATA_STATUS_A(
                ID,
                NAME,
                IS_SUBMITTED_STATUS,
                IS_READY_FOR_PROCESSING_STATUS,
                IS_IN_PROCESS_STATUS,
                IS_REVIEW_REQUIRED_STATUS,
                IS_SEARCHABLE_STATUS,
                IS_ARCHIVED_STATUS,
                IS_DELETED_STATUS,
                IS_IN_ERROR_STATUS,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.NAME,
                OLD.IS_SUBMITTED_STATUS,
                OLD.IS_READY_FOR_PROCESSING_STATUS,
                OLD.IS_IN_PROCESS_STATUS,
                OLD.IS_REVIEW_REQUIRED_STATUS,
                OLD.IS_SEARCHABLE_STATUS,
                OLD.IS_ARCHIVED_STATUS,
                OLD.IS_DELETED_STATUS,
                OLD.IS_IN_ERROR_STATUS,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_data_status_bu() FROM PUBLIC;

CREATE TRIGGER proto_data_status_bu
	BEFORE UPDATE ON proto_data_status FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_data_status_bu();

DROP TRIGGER IF EXISTS proto_data_theme_bd ON proto_data_theme CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_data_theme_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_DATA_THEME_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_DATA_THEME_A(
                    ID,
                    NAME,
                    ICON_NAME,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.NAME,
                    OLD.ICON_NAME,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_DATA_THEME_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME IS NULL OR NAME = OLD.NAME)
                    AND (ICON_NAME IS NULL OR ICON_NAME = OLD.ICON_NAME);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_DATA_THEME_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME = NULL OR NAME = OLD.NAME)
                    AND (ICON_NAME = NULL OR ICON_NAME = OLD.ICON_NAME);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_data_theme_bd() FROM PUBLIC;

CREATE TRIGGER proto_data_theme_bd
	BEFORE DELETE ON proto_data_theme FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_data_theme_bd();

DROP TRIGGER IF EXISTS proto_data_theme_bu ON proto_data_theme CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_data_theme_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_DATA_THEME_A(
                ID,
                NAME,
                ICON_NAME,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.NAME,
                OLD.ICON_NAME,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_data_theme_bu() FROM PUBLIC;

CREATE TRIGGER proto_data_theme_bu
	BEFORE UPDATE ON proto_data_theme FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_data_theme_bu();

DROP TRIGGER IF EXISTS proto_filetype_bd ON proto_filetype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_filetype_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_FILETYPE_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_FILETYPE_A(
                    ID,
                    NAME,
                    DESCRIPTION,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.NAME,
                    OLD.DESCRIPTION,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_FILETYPE_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME IS NULL OR NAME = OLD.NAME)
                    AND (DESCRIPTION IS NULL OR DESCRIPTION = OLD.DESCRIPTION);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_FILETYPE_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME = NULL OR NAME = OLD.NAME)
                    AND (DESCRIPTION = NULL OR DESCRIPTION = OLD.DESCRIPTION);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_filetype_bd() FROM PUBLIC;

CREATE TRIGGER proto_filetype_bd
	BEFORE DELETE ON proto_filetype FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_filetype_bd();

DROP TRIGGER IF EXISTS proto_filetype_bu ON proto_filetype CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_filetype_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_FILETYPE_A(
                ID,
                NAME,
                DESCRIPTION,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.NAME,
                OLD.DESCRIPTION,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_filetype_bu() FROM PUBLIC;

CREATE TRIGGER proto_filetype_bu
	BEFORE UPDATE ON proto_filetype FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_filetype_bu();

DROP TRIGGER IF EXISTS proto_keyword_bd ON proto_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_keyword_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_KEYWORD_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_KEYWORD_A(
                    ID,
                    NAME,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.NAME,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_KEYWORD_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME IS NULL OR NAME = OLD.NAME);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_KEYWORD_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME = NULL OR NAME = OLD.NAME);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_keyword_bd() FROM PUBLIC;

CREATE TRIGGER proto_keyword_bd
	BEFORE DELETE ON proto_keyword FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_keyword_bd();

DROP TRIGGER IF EXISTS proto_keyword_bu ON proto_keyword CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_keyword_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_KEYWORD_A(
                ID,
                NAME,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.NAME,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_keyword_bu() FROM PUBLIC;

CREATE TRIGGER proto_keyword_bu
	BEFORE UPDATE ON proto_keyword FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_keyword_bu();

DROP TRIGGER IF EXISTS proto_location_bd ON proto_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_location_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_LOCATION_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_LOCATION_A(
                    ID,
                    SITE_NAME,
                    LATITUDE,
                    LONGITUDE,
                    STATE,
                    DOMAIN,
                    SITE_CODE,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.SITE_NAME,
                    OLD.LATITUDE,
                    OLD.LONGITUDE,
                    OLD.STATE,
                    OLD.DOMAIN,
                    OLD.SITE_CODE,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_LOCATION_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (SITE_NAME IS NULL OR SITE_NAME = OLD.SITE_NAME)
                    AND (LATITUDE IS NULL OR LATITUDE = OLD.LATITUDE)
                    AND (LONGITUDE IS NULL OR LONGITUDE = OLD.LONGITUDE)
                    AND (STATE IS NULL OR STATE = OLD.STATE)
                    AND (DOMAIN IS NULL OR DOMAIN = OLD.DOMAIN)
                    AND (SITE_CODE IS NULL OR SITE_CODE = OLD.SITE_CODE);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_LOCATION_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (SITE_NAME = NULL OR SITE_NAME = OLD.SITE_NAME)
                    AND (LATITUDE = NULL OR LATITUDE = OLD.LATITUDE)
                    AND (LONGITUDE = NULL OR LONGITUDE = OLD.LONGITUDE)
                    AND (STATE = NULL OR STATE = OLD.STATE)
                    AND (DOMAIN = NULL OR DOMAIN = OLD.DOMAIN)
                    AND (SITE_CODE = NULL OR SITE_CODE = OLD.SITE_CODE);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_location_bd() FROM PUBLIC;

CREATE TRIGGER proto_location_bd
	BEFORE DELETE ON proto_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_location_bd();

DROP TRIGGER IF EXISTS proto_location_bu ON proto_location CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_location_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_LOCATION_A(
                ID,
                SITE_NAME,
                LATITUDE,
                LONGITUDE,
                STATE,
                DOMAIN,
                SITE_CODE,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.SITE_NAME,
                OLD.LATITUDE,
                OLD.LONGITUDE,
                OLD.STATE,
                OLD.DOMAIN,
                OLD.SITE_CODE,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_location_bu() FROM PUBLIC;

CREATE TRIGGER proto_location_bu
	BEFORE UPDATE ON proto_location FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_location_bu();

DROP TRIGGER IF EXISTS proto_pub_citation_bd ON proto_pub_citation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_pub_citation_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_PUB_CITATION_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_PUB_CITATION_A(
                    ID,
                    CITATION,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.CITATION,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_PUB_CITATION_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (CITATION IS NULL OR CITATION = OLD.CITATION);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_PUB_CITATION_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (CITATION = NULL OR CITATION = OLD.CITATION);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_pub_citation_bd() FROM PUBLIC;

CREATE TRIGGER proto_pub_citation_bd
	BEFORE DELETE ON proto_pub_citation FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_pub_citation_bd();

DROP TRIGGER IF EXISTS proto_pub_citation_bu ON proto_pub_citation CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_pub_citation_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_PUB_CITATION_A(
                ID,
                CITATION,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.CITATION,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_pub_citation_bu() FROM PUBLIC;

CREATE TRIGGER proto_pub_citation_bu
	BEFORE UPDATE ON proto_pub_citation FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_pub_citation_bu();

DROP TRIGGER IF EXISTS proto_related_dp_bd ON proto_related_dp CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_related_dp_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_RELATED_DP_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_RELATED_DP_A(
                    ID,
                    DATA_PRODUCT_ID,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.DATA_PRODUCT_ID,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_RELATED_DP_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (DATA_PRODUCT_ID IS NULL OR DATA_PRODUCT_ID = OLD.DATA_PRODUCT_ID);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_RELATED_DP_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (DATA_PRODUCT_ID = NULL OR DATA_PRODUCT_ID = OLD.DATA_PRODUCT_ID);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_related_dp_bd() FROM PUBLIC;

CREATE TRIGGER proto_related_dp_bd
	BEFORE DELETE ON proto_related_dp FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_related_dp_bd();

DROP TRIGGER IF EXISTS proto_related_dp_bu ON proto_related_dp CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_related_dp_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_RELATED_DP_A(
                ID,
                DATA_PRODUCT_ID,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.DATA_PRODUCT_ID,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_related_dp_bu() FROM PUBLIC;

CREATE TRIGGER proto_related_dp_bu
	BEFORE UPDATE ON proto_related_dp FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_related_dp_bu();

DROP TRIGGER IF EXISTS proto_responsible_bd ON proto_responsible CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_responsible_bd() RETURNS trigger AS $BODY$
DECLARE
            row_count numeric;
            max_tran_date timestamp;
BEGIN
  BEGIN
            SELECT MAX(TRAN_DATE) into STRICT max_tran_date
            FROM PROTO_RESPONSIBLE_A
            WHERE ID = OLD.ID;

            IF max_tran_date IS NULL THEN
                SELECT (CURRENT_TIMESTAMP AT TIME ZONE 'UTC') INTO STRICT max_tran_date;
                INSERT INTO PROTO_RESPONSIBLE_A(
                    ID,
                    NAME_1,
                    NAME_2,
                    EMAIL,
                    IS_NEON,
                    IS_PARTY,
                    CHANGE_BY,
                    TRAN_DATE,
                    AUDIT_END_DATE,
                    AUDIT_END_BY,
                    AUDIT_TYPE
                )
                VALUES (
                    OLD.ID,
                    OLD.NAME_1,
                    OLD.NAME_2,
                    OLD.EMAIL,
                    OLD.IS_NEON,
                    OLD.IS_PARTY,
                    OLD.CHANGE_BY,
                    OLD.TRAN_DATE,
                    max_tran_date,
                    OLD.change_by,
                    'D'
                );
            ELSE
                SELECT Count(*) into STRICT row_count
                FROM PROTO_RESPONSIBLE_A
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME_1 IS NULL OR NAME_1 = OLD.NAME_1)
                    AND (NAME_2 IS NULL OR NAME_2 = OLD.NAME_2)
                    AND (EMAIL IS NULL OR EMAIL = OLD.EMAIL)
                    AND (IS_NEON IS NULL OR IS_NEON = OLD.IS_NEON)
                    AND (IS_PARTY IS NULL OR IS_PARTY = OLD.IS_PARTY);

                IF row_count <> 1 THEN
                    RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
                END IF;

                UPDATE PROTO_RESPONSIBLE_A SET AUDIT_TYPE = 'D'
                WHERE ID = OLD.ID
                    AND TRAN_DATE = max_tran_date
                    AND AUDIT_END_BY = OLD.CHANGE_BY
                    AND (NAME_1 = NULL OR NAME_1 = OLD.NAME_1)
                    AND (NAME_2 = NULL OR NAME_2 = OLD.NAME_2)
                    AND (EMAIL = NULL OR EMAIL = OLD.EMAIL)
                    AND (IS_NEON = NULL OR IS_NEON = OLD.IS_NEON)
                    AND (IS_PARTY = NULL OR IS_PARTY = OLD.IS_PARTY);
            END IF;
          END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_responsible_bd() FROM PUBLIC;

CREATE TRIGGER proto_responsible_bd
	BEFORE DELETE ON proto_responsible FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_responsible_bd();

DROP TRIGGER IF EXISTS proto_responsible_bu ON proto_responsible CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_proto_responsible_bu() RETURNS trigger AS $BODY$
BEGIN
            INSERT INTO PROTO_RESPONSIBLE_A(
                ID,
                NAME_1,
                NAME_2,
                EMAIL,
                IS_NEON,
                IS_PARTY,
                CHANGE_BY,
                TRAN_DATE,
                AUDIT_END_DATE,
                AUDIT_END_BY,
                AUDIT_TYPE
            )
            VALUES (
                OLD.ID,
                OLD.NAME_1,
                OLD.NAME_2,
                OLD.EMAIL,
                OLD.IS_NEON,
                OLD.IS_PARTY,
                OLD.CHANGE_BY,
                OLD.TRAN_DATE,
                NEW.tran_date,
                NEW.change_by,
                'U'
            );
        RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_proto_responsible_bu() FROM PUBLIC;

CREATE TRIGGER proto_responsible_bu
	BEFORE UPDATE ON proto_responsible FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_proto_responsible_bu();

DROP TRIGGER IF EXISTS pub_field_def_before_delete ON pub_field_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pub_field_def_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM PUB_FIELD_DEF_A
   WHERE PUB_FIELD_DEF_ID = OLD.PUB_FIELD_DEF_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM PUB_FIELD_DEF_A
   WHERE PUB_FIELD_DEF_ID = OLD.PUB_FIELD_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND PUB_TABLE_DEF_ID = OLD.PUB_TABLE_DEF_ID AND RANK = OLD.RANK AND (DP_NUMBER IS NULL OR DP_NUMBER = OLD.DP_NUMBER) AND FIELD_NAME = OLD.FIELD_NAME AND (DESCRIPTION IS NULL OR DESCRIPTION = OLD.DESCRIPTION) AND DATA_TYPE_CODE = OLD.DATA_TYPE_CODE AND MEAS_SCALE = OLD.MEAS_SCALE AND (ONTOLOGY_MAPPING IS NULL OR ONTOLOGY_MAPPING = OLD.ONTOLOGY_MAPPING) AND PUB_FORMAT = OLD.PUB_FORMAT AND (EXAMPLE_ENTRY IS NULL OR EXAMPLE_ENTRY = OLD.EXAMPLE_ENTRY) AND FIELD_TYPE = OLD.FIELD_TYPE AND (INPUTS IS NULL OR INPUTS = OLD.INPUTS) AND (INGEST_SOURCE_TYPE IS NULL OR INGEST_SOURCE_TYPE = OLD.INGEST_SOURCE_TYPE) AND (INGEST_SOURCE_TYPE_PARAM IS NULL OR INGEST_SOURCE_TYPE_PARAM = OLD.INGEST_SOURCE_TYPE_PARAM) AND (TIME_INDEX IS NULL OR TIME_INDEX = OLD.TIME_INDEX) AND (TIME_DESCRIPTION IS NULL OR TIME_DESCRIPTION = OLD.TIME_DESCRIPTION) AND DOWNLOAD_PACKAGE = OLD.DOWNLOAD_PACKAGE AND DATA_CATEGORY = OLD.DATA_CATEGORY AND (SAMPLE_INFO IS NULL OR SAMPLE_INFO = OLD.SAMPLE_INFO) AND (LOV_CODE IS NULL OR LOV_CODE = OLD.LOV_CODE) AND PRIMARY_KEY = OLD.PRIMARY_KEY AND (UNIT_NAME IS NULL OR UNIT_NAME = OLD.UNIT_NAME) AND (REDACTION_FLAG IS NULL OR REDACTION_FLAG = OLD.REDACTION_FLAG);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE PUB_FIELD_DEF_A SET AUDIT_TYPE = 'D'
   WHERE PUB_FIELD_DEF_ID = OLD.PUB_FIELD_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND PUB_TABLE_DEF_ID = OLD.PUB_TABLE_DEF_ID AND RANK = OLD.RANK AND (DP_NUMBER = NULL OR DP_NUMBER = OLD.DP_NUMBER) AND FIELD_NAME = OLD.FIELD_NAME AND (DESCRIPTION = NULL OR DESCRIPTION = OLD.DESCRIPTION) AND DATA_TYPE_CODE = OLD.DATA_TYPE_CODE AND MEAS_SCALE = OLD.MEAS_SCALE AND (ONTOLOGY_MAPPING = NULL OR ONTOLOGY_MAPPING = OLD.ONTOLOGY_MAPPING) AND PUB_FORMAT = OLD.PUB_FORMAT AND (EXAMPLE_ENTRY = NULL OR EXAMPLE_ENTRY = OLD.EXAMPLE_ENTRY) AND FIELD_TYPE = OLD.FIELD_TYPE AND (INPUTS = NULL OR INPUTS = OLD.INPUTS) AND (INGEST_SOURCE_TYPE = NULL OR INGEST_SOURCE_TYPE = OLD.INGEST_SOURCE_TYPE) AND (INGEST_SOURCE_TYPE_PARAM = NULL OR INGEST_SOURCE_TYPE_PARAM = OLD.INGEST_SOURCE_TYPE_PARAM) AND (TIME_INDEX = NULL OR TIME_INDEX = OLD.TIME_INDEX) AND (TIME_DESCRIPTION = NULL OR TIME_DESCRIPTION = OLD.TIME_DESCRIPTION) AND DOWNLOAD_PACKAGE = OLD.DOWNLOAD_PACKAGE AND DATA_CATEGORY = OLD.DATA_CATEGORY AND (SAMPLE_INFO = NULL OR SAMPLE_INFO = OLD.SAMPLE_INFO) AND (LOV_CODE = NULL OR LOV_CODE = OLD.LOV_CODE) AND PRIMARY_KEY = OLD.PRIMARY_KEY AND (UNIT_NAME = NULL OR UNIT_NAME = OLD.UNIT_NAME) AND (REDACTION_FLAG = NULL OR REDACTION_FLAG = OLD.REDACTION_FLAG);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_pub_field_def_before_delete() FROM PUBLIC;

CREATE TRIGGER pub_field_def_before_delete
	BEFORE DELETE ON pub_field_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_pub_field_def_before_delete();

DROP TRIGGER IF EXISTS pub_field_def_before_update ON pub_field_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pub_field_def_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO PUB_FIELD_DEF_A(
   PUB_FIELD_DEF_ID,
   PUB_TABLE_DEF_ID,
   RANK,
   DP_NUMBER,
   FIELD_NAME,
   DESCRIPTION,
   DATA_TYPE_CODE,
   MEAS_SCALE,
   ONTOLOGY_MAPPING,
   PUB_FORMAT,
   EXAMPLE_ENTRY,
   FIELD_TYPE,
   INPUTS,
   INGEST_SOURCE_TYPE,
   INGEST_SOURCE_TYPE_PARAM,
   TIME_INDEX,
   TIME_DESCRIPTION,
   DOWNLOAD_PACKAGE,
   DATA_CATEGORY,
   SAMPLE_INFO,
   LOV_CODE,
   PRIMARY_KEY,
   CHANGE_BY,
   TRAN_DATE,
   UNIT_NAME,
   REDACTION_FLAG,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.PUB_FIELD_DEF_ID,
   OLD.PUB_TABLE_DEF_ID,
   OLD.RANK,
   OLD.DP_NUMBER,
   OLD.FIELD_NAME,
   OLD.DESCRIPTION,
   OLD.DATA_TYPE_CODE,
   OLD.MEAS_SCALE,
   OLD.ONTOLOGY_MAPPING,
   OLD.PUB_FORMAT,
   OLD.EXAMPLE_ENTRY,
   OLD.FIELD_TYPE,
   OLD.INPUTS,
   OLD.INGEST_SOURCE_TYPE,
   OLD.INGEST_SOURCE_TYPE_PARAM,
   OLD.TIME_INDEX,
   OLD.TIME_DESCRIPTION,
   OLD.DOWNLOAD_PACKAGE,
   OLD.DATA_CATEGORY,
   OLD.SAMPLE_INFO,
   OLD.LOV_CODE,
   OLD.PRIMARY_KEY,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.UNIT_NAME,
   OLD.REDACTION_FLAG,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_pub_field_def_before_update() FROM PUBLIC;

CREATE TRIGGER pub_field_def_before_update
	BEFORE UPDATE ON pub_field_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_pub_field_def_before_update();

DROP TRIGGER IF EXISTS pub_table_def_before_delete ON pub_table_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pub_table_def_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM PUB_TABLE_DEF_A
   WHERE PUB_TABLE_DEF_ID = OLD.PUB_TABLE_DEF_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM PUB_TABLE_DEF_A
   WHERE PUB_TABLE_DEF_ID = OLD.PUB_TABLE_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND DP_IDQ = OLD.DP_IDQ AND (DP_IDQ_SOURCE IS NULL OR DP_IDQ_SOURCE = OLD.DP_IDQ_SOURCE) AND NAME = OLD.NAME AND (DESCRIPTION IS NULL OR DESCRIPTION = OLD.DESCRIPTION) AND USAGE = OLD.USAGE AND (TABLE_TYPE IS NULL OR TABLE_TYPE = OLD.TABLE_TYPE) AND (INGEST_TABLE_DEF_ID IS NULL OR INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID) AND (FILTER_SAMPLE_CLASS IS NULL OR FILTER_SAMPLE_CLASS = OLD.FILTER_SAMPLE_CLASS);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

    UPDATE PUB_TABLE_DEF_A SET AUDIT_TYPE = 'D'
   WHERE PUB_TABLE_DEF_ID = OLD.PUB_TABLE_DEF_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND DP_IDQ = OLD.DP_IDQ AND (DP_IDQ_SOURCE = NULL OR DP_IDQ_SOURCE = OLD.DP_IDQ_SOURCE) AND NAME = OLD.NAME AND (DESCRIPTION = NULL OR DESCRIPTION = OLD.DESCRIPTION) AND USAGE = OLD.USAGE AND (TABLE_TYPE = NULL OR TABLE_TYPE = OLD.TABLE_TYPE) AND (INGEST_TABLE_DEF_ID = NULL OR INGEST_TABLE_DEF_ID = OLD.INGEST_TABLE_DEF_ID) AND (FILTER_SAMPLE_CLASS = NULL OR FILTER_SAMPLE_CLASS = OLD.FILTER_SAMPLE_CLASS);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_pub_table_def_before_delete() FROM PUBLIC;

CREATE TRIGGER pub_table_def_before_delete
	BEFORE DELETE ON pub_table_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_pub_table_def_before_delete();

DROP TRIGGER IF EXISTS pub_table_def_before_update ON pub_table_def CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_pub_table_def_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO PUB_TABLE_DEF_A(
   PUB_TABLE_DEF_ID,
   DP_IDQ,
   DP_IDQ_SOURCE,
   NAME,
   DESCRIPTION,
   USAGE,
   TABLE_TYPE,
   INGEST_TABLE_DEF_ID,
   FILTER_SAMPLE_CLASS,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.PUB_TABLE_DEF_ID,
   OLD.DP_IDQ,
   OLD.DP_IDQ_SOURCE,
   OLD.NAME,
   OLD.DESCRIPTION,
   OLD.USAGE,
   OLD.TABLE_TYPE,
   OLD.INGEST_TABLE_DEF_ID,
   OLD.FILTER_SAMPLE_CLASS,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_pub_table_def_before_update() FROM PUBLIC;

CREATE TRIGGER pub_table_def_before_update
	BEFORE UPDATE ON pub_table_def FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_pub_table_def_before_update();

DROP TRIGGER IF EXISTS release_dp_pub_before_update ON release_dp_pub CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_release_dp_pub_before_update() RETURNS trigger AS $BODY$
BEGIN
    INSERT INTO RELEASE_DP_PUB_A(
       RELEASE_TAG,
       DP_PUB_ID,
       STATUS,
       TRAN_DATE,
       AUDIT_END_DATE,
       AUDIT_TYPE
    )
    VALUES (
       OLD.RELEASE_TAG,
       OLD.DP_PUB_ID,
       OLD.STATUS,
       OLD.TRAN_DATE,
       NEW.tran_date,
       'U'
    );
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_release_dp_pub_before_update() FROM PUBLIC;

CREATE TRIGGER release_dp_pub_before_update
	BEFORE UPDATE ON release_dp_pub FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_release_dp_pub_before_update();

DROP TRIGGER IF EXISTS term_before_delete ON term CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_term_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM TERM_A
   WHERE TERM_NAME = OLD.TERM_NAME;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM TERM_A
   WHERE TERM_NAME = OLD.TERM_NAME AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (TERM_NUMBER IS NULL OR TERM_NUMBER = OLD.TERM_NUMBER) AND (TERM_DESCRIPTION IS NULL OR TERM_DESCRIPTION = OLD.TERM_DESCRIPTION) AND UNIT_NAME = OLD.UNIT_NAME AND (VAL_NID IS NULL OR VAL_NID = OLD.VAL_NID) AND (VAL_ID IS NULL OR VAL_ID = OLD.VAL_ID) AND (MEASUREMENT_SCALE IS NULL OR MEASUREMENT_SCALE = OLD.MEASUREMENT_SCALE) AND DATA_TYPE_CODE = OLD.DATA_TYPE_CODE AND (RELATED_TERMS IS NULL OR RELATED_TERMS = OLD.RELATED_TERMS) AND ACTIVE = OLD.ACTIVE;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE TERM_A SET AUDIT_TYPE = 'D'
   WHERE TERM_NAME = OLD.TERM_NAME AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (TERM_NUMBER = NULL OR TERM_NUMBER = OLD.TERM_NUMBER) AND (TERM_DESCRIPTION = NULL OR TERM_DESCRIPTION = OLD.TERM_DESCRIPTION) AND UNIT_NAME = OLD.UNIT_NAME AND (VAL_NID = NULL OR VAL_NID = OLD.VAL_NID) AND (VAL_ID = NULL OR VAL_ID = OLD.VAL_ID) AND (MEASUREMENT_SCALE = NULL OR MEASUREMENT_SCALE = OLD.MEASUREMENT_SCALE) AND DATA_TYPE_CODE = OLD.DATA_TYPE_CODE AND (RELATED_TERMS = NULL OR RELATED_TERMS = OLD.RELATED_TERMS) AND ACTIVE = OLD.ACTIVE;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_term_before_delete() FROM PUBLIC;

CREATE TRIGGER term_before_delete
	BEFORE DELETE ON term FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_term_before_delete();

DROP TRIGGER IF EXISTS term_before_update ON term CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_term_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO TERM_A(
   TERM_NAME,
   TERM_NUMBER,
   TERM_DESCRIPTION,
   UNIT_NAME,
   VAL_NID,
   VAL_ID,
   MEASUREMENT_SCALE,
   DATA_TYPE_CODE,
   RELATED_TERMS,
   ACTIVE,
   CHANGE_BY,
   TRAN_DATE,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.TERM_NAME,
   OLD.TERM_NUMBER,
   OLD.TERM_DESCRIPTION,
   OLD.UNIT_NAME,
   OLD.VAL_NID,
   OLD.VAL_ID,
   OLD.MEASUREMENT_SCALE,
   OLD.DATA_TYPE_CODE,
   OLD.RELATED_TERMS,
   OLD.ACTIVE,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_term_before_update() FROM PUBLIC;

CREATE TRIGGER term_before_update
	BEFORE UPDATE ON term FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_term_before_update();

DROP TRIGGER IF EXISTS threshold_before_delete ON threshold CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_threshold_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM THRESHOLD_A
   WHERE THRESHOLD_UUID = OLD.THRESHOLD_UUID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM THRESHOLD_A
   WHERE THRESHOLD_UUID = OLD.THRESHOLD_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND DP_IDQ = OLD.DP_IDQ AND CONDITION_TYPE_ID = OLD.CONDITION_TYPE_ID AND THRESHOLD_NAME = OLD.THRESHOLD_NAME AND (THRESHOLD_DESC IS NULL OR THRESHOLD_DESC = OLD.THRESHOLD_DESC) AND (TERM_NAME IS NULL OR TERM_NAME = OLD.TERM_NAME);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE THRESHOLD_A SET AUDIT_TYPE = 'D'
   WHERE THRESHOLD_UUID = OLD.THRESHOLD_UUID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND DP_IDQ = OLD.DP_IDQ AND CONDITION_TYPE_ID = OLD.CONDITION_TYPE_ID AND THRESHOLD_NAME = OLD.THRESHOLD_NAME AND (THRESHOLD_DESC = NULL OR THRESHOLD_DESC = OLD.THRESHOLD_DESC) AND (TERM_NAME = NULL OR TERM_NAME = OLD.TERM_NAME);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_threshold_before_delete() FROM PUBLIC;

CREATE TRIGGER threshold_before_delete
	BEFORE DELETE ON threshold FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_threshold_before_delete();

DROP TRIGGER IF EXISTS threshold_before_update ON threshold CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_threshold_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO THRESHOLD_A(
   THRESHOLD_UUID,
   DP_IDQ,
   CONDITION_TYPE_ID,
   THRESHOLD_NAME,
   CHANGE_BY,
   TRAN_DATE,
   THRESHOLD_DESC,
   TERM_NAME,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.THRESHOLD_UUID,
   OLD.DP_IDQ,
   OLD.CONDITION_TYPE_ID,
   OLD.THRESHOLD_NAME,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.THRESHOLD_DESC,
   OLD.TERM_NAME,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_threshold_before_update() FROM PUBLIC;

CREATE TRIGGER threshold_before_update
	BEFORE UPDATE ON threshold FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_threshold_before_update();

DROP TRIGGER IF EXISTS type_before_delete ON type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_type_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM TYPE_A
   WHERE TYPE_ID = OLD.TYPE_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM TYPE_A
   WHERE TYPE_ID = OLD.TYPE_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TYPE_NAME = OLD.TYPE_NAME AND TYPE_NID = OLD.TYPE_NID AND TYPE_TYPE_ID = OLD.TYPE_TYPE_ID AND (PRNT_TYPE_ID IS NULL OR PRNT_TYPE_ID = OLD.PRNT_TYPE_ID);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE TYPE_A SET AUDIT_TYPE = 'D'
   WHERE TYPE_ID = OLD.TYPE_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TYPE_NAME = OLD.TYPE_NAME AND TYPE_NID = OLD.TYPE_NID AND TYPE_TYPE_ID = OLD.TYPE_TYPE_ID AND (PRNT_TYPE_ID = NULL OR PRNT_TYPE_ID = OLD.PRNT_TYPE_ID);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_type_before_delete() FROM PUBLIC;

CREATE TRIGGER type_before_delete
	BEFORE DELETE ON type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_type_before_delete();

DROP TRIGGER IF EXISTS type_before_update ON type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_type_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO TYPE_A(
   TYPE_ID,
   TYPE_NAME,
   TYPE_NID,
   TYPE_TYPE_ID,
   PRNT_TYPE_ID,
   TRAN_DATE,
   CHANGE_BY,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.TYPE_ID,
   OLD.TYPE_NAME,
   OLD.TYPE_NID,
   OLD.TYPE_TYPE_ID,
   OLD.PRNT_TYPE_ID,
   OLD.TRAN_DATE,
   OLD.CHANGE_BY,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_type_before_update() FROM PUBLIC;

CREATE TRIGGER type_before_update
	BEFORE UPDATE ON type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_type_before_update();

DROP TRIGGER IF EXISTS type_type_before_delete ON type_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_type_type_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM TYPE_TYPE_A
   WHERE TYPE_TYPE_ID = OLD.TYPE_TYPE_ID;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM TYPE_TYPE_A
   WHERE TYPE_TYPE_ID = OLD.TYPE_TYPE_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TYPE_TYPE_NAME = OLD.TYPE_TYPE_NAME AND TYPE_TYPE_NID = OLD.TYPE_TYPE_NID;

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE TYPE_TYPE_A SET AUDIT_TYPE = 'D'
   WHERE TYPE_TYPE_ID = OLD.TYPE_TYPE_ID AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND TYPE_TYPE_NAME = OLD.TYPE_TYPE_NAME AND TYPE_TYPE_NID = OLD.TYPE_TYPE_NID;
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_type_type_before_delete() FROM PUBLIC;

CREATE TRIGGER type_type_before_delete
	BEFORE DELETE ON type_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_type_type_before_delete();

DROP TRIGGER IF EXISTS type_type_before_update ON type_type CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_type_type_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO TYPE_TYPE_A(
   TYPE_TYPE_ID,
   TYPE_TYPE_NAME,
   TYPE_TYPE_NID,
   TRAN_DATE,
   CHANGE_BY,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.TYPE_TYPE_ID,
   OLD.TYPE_TYPE_NAME,
   OLD.TYPE_TYPE_NID,
   OLD.TRAN_DATE,
   OLD.CHANGE_BY,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_type_type_before_update() FROM PUBLIC;

CREATE TRIGGER type_type_before_update
	BEFORE UPDATE ON type_type FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_type_type_before_update();

DROP TRIGGER IF EXISTS unit_before_delete ON unit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_unit_before_delete() RETURNS trigger AS $BODY$
DECLARE
   row_count numeric;
   max_tran_date timestamp;
BEGIN
  BEGIN
   SELECT MAX(TRAN_DATE) into STRICT max_tran_date
   FROM UNIT_A
   WHERE UNIT_NAME = OLD.UNIT_NAME;

   IF max_tran_date IS NULL THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45001';
   END IF;

   SELECT Count(*) into STRICT row_count
   FROM UNIT_A
   WHERE UNIT_NAME = OLD.UNIT_NAME AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (UNIT_ABBR IS NULL OR UNIT_ABBR = OLD.UNIT_ABBR) AND (UNIT_DESC IS NULL OR UNIT_DESC = OLD.UNIT_DESC) AND (VERSION_START_DATE IS NULL OR VERSION_START_DATE = OLD.VERSION_START_DATE) AND (VERSION_END_DATE IS NULL OR VERSION_END_DATE = OLD.VERSION_END_DATE) AND (SOURCE_ID IS NULL OR SOURCE_ID = OLD.SOURCE_ID) AND (UNIT_TYPE_NAME IS NULL OR UNIT_TYPE_NAME = OLD.UNIT_TYPE_NAME) AND (PARENT_SI IS NULL OR PARENT_SI = OLD.PARENT_SI) AND (MULTIPLIER_TO_SI IS NULL OR MULTIPLIER_TO_SI = OLD.MULTIPLIER_TO_SI) AND (CONSTANT_TO_SI IS NULL OR CONSTANT_TO_SI = OLD.CONSTANT_TO_SI) AND (MEAS_SCALE IS NULL OR MEAS_SCALE = OLD.MEAS_SCALE) AND (UNIT_ID IS NULL OR UNIT_ID = OLD.UNIT_ID) AND (UNIT_ABBR_MATH_JAX IS NULL OR UNIT_ABBR_MATH_JAX = OLD.UNIT_ABBR_MATH_JAX) AND (EML_ATTR IS NULL OR EML_ATTR = OLD.EML_ATTR) AND (PROPOSED_DATE_DPS IS NULL OR PROPOSED_DATE_DPS = OLD.PROPOSED_DATE_DPS) AND (START_USE_DATE_DPS IS NULL OR START_USE_DATE_DPS = OLD.START_USE_DATE_DPS) AND (DISCONTINUE_USE_DATE_DPS IS NULL OR DISCONTINUE_USE_DATE_DPS = OLD.DISCONTINUE_USE_DATE_DPS) AND (UNIT_REPLACES IS NULL OR UNIT_REPLACES = OLD.UNIT_REPLACES) AND (REFERENCE_URL IS NULL OR REFERENCE_URL = OLD.REFERENCE_URL) AND (REFERENCE_CITATION IS NULL OR REFERENCE_CITATION =
OLD.REFERENCE_CITATION);

   IF row_count <> 1 THEN
      RAISE EXCEPTION '%', 'UNABLE TO DELETE: No corresponding record in audit table.' USING ERRCODE = '45002';
   END IF;

   UPDATE UNIT_A SET AUDIT_TYPE = 'D'
   WHERE UNIT_NAME = OLD.UNIT_NAME AND TRAN_DATE = max_tran_date AND AUDIT_END_BY = OLD.CHANGE_BY AND (UNIT_ABBR = NULL OR UNIT_ABBR = OLD.UNIT_ABBR) AND (UNIT_DESC = NULL OR UNIT_DESC = OLD.UNIT_DESC) AND (VERSION_START_DATE = NULL OR VERSION_START_DATE = OLD.VERSION_START_DATE) AND (VERSION_END_DATE = NULL OR VERSION_END_DATE = OLD.VERSION_END_DATE) AND (SOURCE_ID = NULL OR SOURCE_ID = OLD.SOURCE_ID) AND (UNIT_TYPE_NAME = NULL OR UNIT_TYPE_NAME = OLD.UNIT_TYPE_NAME) AND (PARENT_SI = NULL OR PARENT_SI = OLD.PARENT_SI) AND (MULTIPLIER_TO_SI = NULL OR MULTIPLIER_TO_SI = OLD.MULTIPLIER_TO_SI) AND (CONSTANT_TO_SI = NULL OR CONSTANT_TO_SI = OLD.CONSTANT_TO_SI) AND (MEAS_SCALE = NULL OR MEAS_SCALE = OLD.MEAS_SCALE) AND (UNIT_ID = NULL OR UNIT_ID = OLD.UNIT_ID) AND (UNIT_ABBR_MATH_JAX = NULL OR UNIT_ABBR_MATH_JAX = OLD.UNIT_ABBR_MATH_JAX) AND (EML_ATTR = NULL OR EML_ATTR = OLD.EML_ATTR) AND (PROPOSED_DATE_DPS = NULL OR PROPOSED_DATE_DPS = OLD.PROPOSED_DATE_DPS) AND (START_USE_DATE_DPS = NULL OR START_USE_DATE_DPS = OLD.START_USE_DATE_DPS) AND (DISCONTINUE_USE_DATE_DPS = NULL OR DISCONTINUE_USE_DATE_DPS = OLD.DISCONTINUE_USE_DATE_DPS) AND (UNIT_REPLACES = NULL OR UNIT_REPLACES = OLD.UNIT_REPLACES) AND (REFERENCE_URL = NULL OR REFERENCE_URL = OLD.REFERENCE_URL) AND (REFERENCE_CITATION = NULL OR REFERENCE_CITATION =
OLD.REFERENCE_CITATION);
  END;
RETURN OLD;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_unit_before_delete() FROM PUBLIC;

CREATE TRIGGER unit_before_delete
	BEFORE DELETE ON unit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_unit_before_delete();

DROP TRIGGER IF EXISTS unit_before_update ON unit CASCADE;
CREATE OR REPLACE FUNCTION trigger_fct_unit_before_update() RETURNS trigger AS $BODY$
BEGIN
INSERT INTO UNIT_A(
   UNIT_NAME,
   UNIT_ABBR,
   UNIT_DESC,
   VERSION_START_DATE,
   VERSION_END_DATE,
   SOURCE_ID,
   UNIT_TYPE_NAME,
   PARENT_SI,
   MULTIPLIER_TO_SI,
   CONSTANT_TO_SI,
   MEAS_SCALE,
   UNIT_ID,
   UNIT_ABBR_MATH_JAX,
   EML_ATTR,
   PROPOSED_DATE_DPS,
   START_USE_DATE_DPS,
   DISCONTINUE_USE_DATE_DPS,
   UNIT_REPLACES,
   CHANGE_BY,
   TRAN_DATE,
   REFERENCE_URL,
   REFERENCE_CITATION,
   AUDIT_END_DATE,
   AUDIT_END_BY,
   AUDIT_TYPE
)
VALUES (
   OLD.UNIT_NAME,
   OLD.UNIT_ABBR,
   OLD.UNIT_DESC,
   OLD.VERSION_START_DATE,
   OLD.VERSION_END_DATE,
   OLD.SOURCE_ID,
   OLD.UNIT_TYPE_NAME,
   OLD.PARENT_SI,
   OLD.MULTIPLIER_TO_SI,
   OLD.CONSTANT_TO_SI,
   OLD.MEAS_SCALE,
   OLD.UNIT_ID,
   OLD.UNIT_ABBR_MATH_JAX,
   OLD.EML_ATTR,
   OLD.PROPOSED_DATE_DPS,
   OLD.START_USE_DATE_DPS,
   OLD.DISCONTINUE_USE_DATE_DPS,
   OLD.UNIT_REPLACES,
   OLD.CHANGE_BY,
   OLD.TRAN_DATE,
   OLD.REFERENCE_URL,
   OLD.REFERENCE_CITATION,
   NEW.tran_date,
   NEW.change_by,
   'U'
);
RETURN NEW;
END
$BODY$
 LANGUAGE 'plpgsql' SECURITY DEFINER;
-- REVOKE ALL ON FUNCTION trigger_fct_unit_before_update() FROM PUBLIC;

CREATE TRIGGER unit_before_update
	BEFORE UPDATE ON unit FOR EACH ROW
	EXECUTE PROCEDURE trigger_fct_unit_before_update();

